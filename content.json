{"pages":[],"posts":[{"title":"Flask Web框架","text":"Flask Web框架安装pip install Flask==1.1.1 在pycharm里直接新建项目,选择flask项目创建,设置虚拟环境等. 解释器(interpreter) Flask – Flask库文件 Jinja2 –模板语言 MarkupSafe –返回安全标签(Flask依赖markupsafe返回安全标签) Werkzeug –(德语’工具’得意思)相当于uWSGI(应用存取网关接口),底层仍为WSGI 启动Flask123456789101112from flask import Flask # 导入Flask类创建Flask应用对象app = Flask(__name__) # app = application@app.route('/') # 为Flask应用对象添加路由def hello_world(): # 与路由绑定得视图函数,名称保持唯一 return 'Hello World!' # 相当于Django中得HttpResponseif __name__ == '__main__': # 当前文件处于脚本状态时运行如下代码 app.run() # 启动Flask应用 Flask中的Response HttpResponse “hello world!” render(‘html文件’) render_template(‘html文件’) redirect(‘/home’) redirect(‘/home’) #3xx开头根据指令做出响应 #4xx 错误 客户端 #5xx 错误 服务器 #302 HTTP status ResponseHeaders中加入一个Localtion:http://url send_file(‘文件路径’) 返回文件 123@app.route('/get_file')def get_file(): return send_file('1.jpg') #打开并返回文件内容.Content-Type:可以被客户端识别得文件类型. #在ResponseHeaders中加入,不能识别得类型,下载处理. jsonify(‘字符串或数据类型’) 返回JSON字符串 123456@app.route('/get_json')def get_json(): d = {d 'name':'Alexander.DSB.Li' } return jsonify(d) #Content-Type:appliaction/json 返回标准格式的JSON字符串 #直接返回dict时,本质上在执行jsonify() Flask中的request123@app.route('/login', methods=['POST','GET'])def login(): return render_template('login.html') methods=['GET','POST']在路由的装饰器中允许请求方式. request.form.to_dict()获取FormData中得数据to_dict(),ImmutableMultiDict request.methods 获取请求方式 request.args.get(‘id) 获取URL中得数据字符串.支持get(‘key’)和to_dict() request.files.get(‘my_file’) 提取文件.获取一个FileStorage Flask文件特殊对象. my_file.save(my_file.filename) 12345678&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;p&gt; username: &lt;input type=\"text\" name=\"'username\"&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"my_file\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt;","link":"/2020/04/17/Flask%20Web%E6%A1%86%E6%9E%B6/"},{"title":"firefox","text":"扩展插件被阻止安装。Firefox Developer Edition已阻止此网站安装未经验证的附加组件。 在地址栏中输入about:config 按x找到 xpinstall.signatures.required 设置为false.","link":"/2020/04/17/firefox/"},{"title":"npm 换源","text":"国内源 淘宝npm镜像 搜索地址: http://npm.taobao.org registry地址: http://registry.npm.taobao.org cnpmjs镜像 搜索地址: http://cnpmjs.org registry地址: http://r.cnpmjs.org 使用方法 临时使用 npm –registry https://registry.npm.taobao.org install express 永久使用 npm config set registry https://registry.npm.taobao.org 使用cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org","link":"/2020/04/17/npm%20%E6%8D%A2%E6%BA%90/"},{"title":"linux-command-line","text":"1. 什么是shellshell是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。bash是来自GNU项目的shell程序。bash是“Bourne Again Shell”的首字母缩写。bash是最初Unix上由Steve Bourne写成shell程序sh的增强版。 1.1. shell技巧移动光标：借助上箭头按键获得上次输入的命令.借助左右按键把光标定位到命令行的任意位置。tab：tab按键具有文件/目录/命令的补全功能。 1.2. shell命令 date 日期 cal 日历 df 查看磁盘剩余空间。 free 查看空闲内存。 exit 退出shell。 pwd 打印当前目录名。 ls 列出目录内容 . 指工作目录 .. 指工作目录的父目录 cd 更改目录 cd - 更改目录到先前的目录 cd ~user_name 更改工作目录到用户家目录. 注:linux对大小写敏感且没有文件扩展名的概念.文件名支持标点符号仅限使用”.”和”-“及”_”. file 当调用file命令后，file命令会打印出文件内容的简单描述。 less 用来浏览文本文件的程序. 2. linux系统中的目录 / 根目录,万物之源. /bin 包含系统启动和运行所必须的二进制程序. /boot 包含Linux内核,最初的RMA磁盘映像和启动加载程序. /boot/grub/grub.conf or menu.lst,用来配置启动加载程序. /boot/vmlinuz,linux内核 /dev 包含设备节点的特殊目录.”一切皆是文件”,也适用于设备.内核维护着它的支持设备. /etc 包含所有系统层面的配置文件.同时也包含一系列的shell脚本,在系统启动时,这些脚本会运行每个系统服务.这个目录中的任何文件都应该是可读文本文件. /etc/crontab,定义自动运行的任务. /etc/fstab,包含存储设备的列表及相关挂载点. /etc/passwd,包含用户账号列表. /home 系统会在/home下,为每个用户分配一个工作目录. /lib 包含核心系统程序所需的库文件.类似windows中的动态链接库. /lost+found 每个使用linux文件系统的格式化分区或设备,都会有这个目录.当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录是空的，除非文件系统损坏。 /media 包含可移动介质的挂载点。 /mnt 早些的系统中，/mnt目录包含可以东介质的挂载点。 /opt 用来安装“可选”软件。用来存储可能安装在系统中的商业软件产品。 /proc 是一个由Linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。这些可读的文件告诉你内核是怎样监管你的计算机的。 /root root账户的家目录。 /sbin 包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 /tmp 用来存储由各种程序创建的临时文件的地方。 /usr 包含普通用户所需要的所有程序和文件。 /usr/bin 包含系统安装的执行程序。 /usr/lib 包含/usr/bin目录中的程序所用的共享库。 /usr/local 非系统发行版自带程序的安装目录。通常由源码编译的程序会安装在/usr/local/bin目录下。 /usr/sbin 包含许多系统管理程序。 /usr/share 包含许多由/usr/bin目录中的程序使用的共享数据。其中包括默认的配置文件、图表、桌面北京、音频文件等等。 /usr/share/doc 包含安装在系统中的软件包的文档。 /var 存放的是动态文件。各种数据库，假脱机文件，用户邮件等等。 /var/log 包含日至文件、各种系统活动的记录。其中/var/log/messages很重要。 3. 符号链接创建硬链接 ln 当创建文件硬链接，实际是为文件创建了额外的名字部分，并且名字关联到相同的数据部分。硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。创建符号链接 ln -s 创建符号链接既可以使用绝对路径也可以使用相对路径名。符号链接可以关联目录。 4. 命令的使用命令的四种形式： 1.可执行程序. 2.内建于shell自身的命令. 3.shell函数. 4.命令别名.自定义自己的命令,尖子在其他命令之上.4.1. 命令的识别type type command shell的内部命令,它会显示命令的类别.which 确定所执行程序的准确位置.只对可执行程序有效,不包括内建命令和命令别名. 4.2. 命令的文档4.2.1. help得到shell内建命令的帮助文档.bash有一个内建的帮助工具.–help 很多执行程序支持一个–help选项,这个想象是显示命令所支持的语法和选项说明. 4.2.2. manman program(program是要浏览的命令名) 显示程序手册页.许多可执行程序提供了一个正式的文档,叫做手册页(man page). 4.2.3. apropos显示适当的命令.注意:man命令加上”-k”选项与apropos完成一样的功能. 4.2.4. whatis 显示非常简介的命令说明4.2.5. info显示程序Info条目.GNU项目提供了一个命令程序手册页的替代五,称其为”info”. 4.2.6. README和其它程序文档 位于/usr/share/doc目录下的文本文件,可用less阅读器来浏览.以”.gz”结尾的文件是用gzip压缩程序压缩的.gzip软件包包含了一个特殊的less版本,叫做zless,可以显示由gzip压缩的文本文件内容. 4.2.7. 创建自己的命令command1;command2;command3… 例: cd /usr; ls; cd -首先使用type 检测”command name”是否被使用.通过 alias foo=’cd /usr;ls/cd -‘来创建命令.使用 unalias foo 命令来删除创建的foo命令. 5. 重定向I/O重定向.”I/O”代表输入/输出,通过此工具可以重定向命令的输入输出,命令输入输出均来自文件.也可以把多个命令联结起来组成强大的命令管道. 5.1. shell命令 cat 连接文件.例:cat movie.mpeg.0* &gt; movie.mpeg 因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。 sort 排序文本行 uniq 报道或省略重复行 grep 打印匹配行 wc 打印文件中换行符,字和字节个数. head 输出文件第一部分 tail 输出文件最后一部分 tee 从标准输入读取数据并写道标准输出和文件. 许多程序都会产生某种输出.经常由两种类型组成. 程序运行结果. 状态和错误信息. I/O重定向允许我们梗概输出地点和输入来源.一般输入来自键盘,输出送到屏幕.通过I/O重定向,我们可以改变. shell将文件流的前三个称作标准输入,标准输出和错误,称为表述副0,1,2. 5.2. 标准输出重定向 filename 将标准输出重定向到除屏幕意外的另一个文件.例:ls -l /bin/usr &gt;ls-output.txt text.txt 没有命令在它之前,这回清空同名的文件内容或创建空文件. filename 将重定向结果追加到文件内容或后面. 5.3. 标准错误重定向例:ls -l /bin/usr 2&gt;ls-error.txt 文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。 5.3.1. 重定向标准输出和错误到同一文件 方法一: 例:ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2&gt;&amp;1。重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。 方法二: 例:ls -l /bin/usr &amp;&gt; ls-output.txt 用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt。 5.3.2. 处理不需要的输出系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。 例:ls -l /bin/usr 2&gt; /dev/null 5.4. 标准输入重定向 例:cat &gt; lazy_dog.txt The quick brown fox jumped over the lazy dog. 输入命令，其后输入要放入文件中的文本。输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）.通过使用这个命令，我们 实现了世界上最低能的文字处理器！ 例:cat &lt; lazy_dog.txt 使用”&lt;”重定向操作符,把标准输入源从键盘改到文件lazy_dog.txt. 5.4.1. 管道线 | command1 | command2 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入. 例:ls -l /usr/bin | less 5.4.2. 过滤器管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。 例:ls /bin /usr/bin | sort | less 因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个有序列表。 5.4.3. uniq报道或忽略重复行 默认情况下，从数据列表中删除任何重复行。uniq 命令经常和 sort 命令结合在一起使用。 例:ls /bin /usr/bin | sort | uniq | less 使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项. 5.5. wc打印行数,字数和字节数 wc命令是用来显示文件所包含的行数,字数和字节数.它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。 5.6. grepgrep pattern [file…] 打印匹配行 用来找到文件中的匹配文本。grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。 5.7. head / tail打印文件开头部分/结尾部分.head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。 tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。 5.8. tee从 Stdin 读取数据，并同时输出到 Stdout 和文件 tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。 例:ls /usr/bin | tee ls.txt | grep zip在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt. 6. 从shell眼中看世界6.1. 字符展开 echo 显示一行文本。传递到 echo 命令的任一个参数都会在（屏幕上）显示出来。 echo * ”“字符意味着匹配文件名中的任意字符，shell 在 echo 命 令被执行前把”“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。 6.2. 路径名展开echo ls -d .[!.]?* 这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：ls -A 6.3. 波浪线展开波浪线字符”~”有特殊的含义.当用在一个单词的开头时,它会展开成制定用户的家目录名,如果没有制定用户名,则展开成当前用户的家目录. 6.4. 算术表达式展开$((expression)) （以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。 算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。在算术表达式中空格并不重要，并且表达式可以嵌套。 6.5. 花括号展开花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列的整数，或者单个的字符串。这种模式不能 嵌入空白字符。 例:echo Number_{1..5} echo {A..Z} echo Front-{A,B,C}-Back 花括号展开可以嵌套：echo a{A{1,2},B{3,4}}b 用花括号展开创建一系列文件/目录 例:mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}6.6. 参数展开它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。 例: echo $USER 要查看有效的变量列表,使用 printenv | less6.7. 命令替换命令替换允许我们把一个命令的输出作为一个展开模式来使用. 例: echo $(ls) ls -l $(which cp) file $(ls -l /usr/bin/* |grep zip)在bash中,也可以使用另一种语法—使用倒引号替代美元符号和括号. ls -l which cp 6.8. 引用shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。 6.8.1. 双引号如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割、路径名展开、 波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。 例: ls -l &quot;two words.txt&quot; echo &quot;this is a test&quot;在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。 echo “this is a test” 单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。 事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影响。echo $(cal)与echo “$(cal)”.在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中， 命令行只有一个参数，参数中包括嵌入的空格和换行符。 6.8.2. 单引号如果需要禁止所有的展开，我们要使用单引号。 6.8.3. 转义字符有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符. 使用转义字符来消除文件名中一个字符的特殊含义 .mv bad$filename good_filename. 反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种 特殊字符，这些特殊字符叫做控制码。ASCII 编码表中前32个字符被用来把命令转输到电报机 之类的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），而其它 一些编码就不熟悉了（空值，传输结束码，和确认）。 \\a 响铃（”警告”－导致计算机嘟嘟响） \\b 退格符 \\n 新的一行。在类 Unix 系统中，产生换行。 \\r 回车符 \\t 制表符 这种利用反斜杠的表示法背后的思想来源于 C 编程语言， 许多其它语言也采用了这种表示方法，包括 shell。 7. 键盘高级操作技巧将要学习的命令： clear 清空屏幕 history 显示历史列表内容 7.1. 命令行编辑Bash使用一个名为Readline的库（共享的例程几何，可以被不同的程序使用），用以实现命令行编辑。 7.1.1. 移动光标 Ctrl-a 移动光标到行首 Ctrl-e 移动光标到行尾 Ctrl-f 光标前移一个字符；和右箭头作用一样。 Ctrl-b 光标后移一个字符；和左箭头一样。 Alt-f 光标前移一个字。 Alt-f 光标前移一个字。 Alt-b 光标后移一个字。 Ctrl-l 清空屏幕，移动光标到左上角。clear命令完成同样的工作。 7.1.2. 修改文本 Ctrl-d 删除光标位置的字符。 Ctrl-t 光标位置的字符和光标前面的字符互换位置。 Alt-t 光标位置的字和其前面的字互换位置。 Alt-l 把从光标位置到字尾的字符转换成小写字母。 Alt-u 把从光标位置到字尾的字符转换成大写字母。 7.1.3. 剪切和粘贴文本Readline的文档使用术语killing和yanking来指我们平常所说的剪切和粘贴。剪切下来的本文被存储在一个叫做剪切环（kill-ring）的缓冲区中。 Ctrl-k 剪切从光标位置到行为的文本。 Ctrl-u 将剪切从光标位置到行首的文本。 Alt-d 剪切从光标位置到词尾的文本。 Alt-Backspace 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。 Ctrl-y 把剪切环中的文本粘贴到光标位置。 7.1.4. 自动补全shell能帮助你的另一种方式是通过一种叫做自动补全的机制。 Alt-？ 显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按项次tab键，这会更容易些。 Alt-* 插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。 7.2. 利用历史命令bash维护着一个已经执行过的命令的历史离别。这个命令列表被保存在你家目录下，一个名为.bash_history的文件里。 7.3. 搜索历史命令history |grep /usr/bin 以及 !88 递增搜索 Ctrl-r 启动递增搜索，其后输入要寻找的文本。 Ctrl-p 移动到上一个历史条目。类似于上箭头按键。 Ctrl-n 移动到下一个历史条目。类似于下箭头按键。 Alt-&lt; 移动到历史列表开头 Alt-&gt; 移动到历史列表结尾,即当前命令行. Ctrl-r 反向递增搜索.从当前命令行开始,向上递增搜索. Alt-p 反向搜索,非递增顺序.输入要查找的字符串,然后按下Enter,执行搜索. Alt-n 向前搜索,非递增顺序. Ctrl-o 执行历史列表中的当前项,并移到下一个.如果你想要执行历史列表中一系列的命令,这很方便. 7.4. 历史命令展开 !number 重复历史列表中第number行的命令. !! 重复最后一次执行的命令.可能按下上箭头按键和enter键更容易. !string 重复最近历史列表中,以这个字符串开头的命令. !?string 重复最近历史列表中,包含这个字符串的命令. 8. 权限8.1. 拥有者,组成员和其他人id 用于查看当前用户的身份信息.用户账号自定义在/etc/passwd 文件中,用户组定义在/etc/group文件中.这些文件随着文件/etc/shadow的变动而修改. 8.2. 读取写入和执行 - 一个普通文件 d 一个目录 l 一个符号链接.注意对于符号链接文件,生于的文件属性总是”rwxrwxrwx”,而且都是虚拟值.真正的文件属性是指符号链接所之乡的文件的属性. c 一个字符设备文件.这种文件类型是指按照字节流来处理数据的设备.比如说终端机或者调制解调器. b 一个块设备文件.这种文件类型是指按照数据块来处理数据的设备,例如一个硬盘或者CD-ROM盘. 剩下的九个字符叫做文件模式,代表着文件所有者\\文件组所有者和其他人的读\\写和执行权限. r 文件:允许打开并读取文件内容. 目录:允许列出目录中的内容,前提是目录必须设置了可执行属性. w 文件:允许写入文件内容或截断文件.但是不允许对文件进行重命名或删除,重命名或删除是由目录的属性决定的. 目录:允许在目录下新建\\删除或重命名文件,前提是目录必须设置了可执行属性(x). x 文件:允许将文件作为程序来执行,使用脚本语言编写的程序必须设置为可读才能被执行. 目录:允许进入目录,例如:cd directory. 8.3. chmod更改文件模式只有文件的所有者或者超级用户才能更改文件或目录的模式.chmod命令支持两种不同的方法来改变文件模式:八进制数字表示法或符号表示法. 八进制表示法: 0 000 — 1 001 –x 2 010 -w- 3 011 -wx 4 100 r– 5 101 r-x 6 110 rw- 7 111 rwx 每个八进制数字代表了3个二进制数字,这种对应关系,正好映射到用来存储文件模式所使用的方案上.7(rwx),6(rw-),5(r-x),4(r–),0(—).八进制的7用二进制表示为111. 符号表示法: u “user”的简写,意思是文件或目录的所有者. g “group”的简写.用户组 o “others””的简写,意思是其他所有的人. a “all”的简写,是”u”,”g”和”o”的联合. chmod符号表示法实例: u+x 为文件所有者添加可执行权限. u-x 删除文件所有者的可执行权限. +x 为文件所有者,用户组和其他所有人添加可执行权限.等价于a+x. o-rw 除了文件所有者和用户组,删除其他人的读权限和写权限. go=rw 给群组的主任和人以文件拥有着的人读写权限.如果群组的主人或全局之前已经有了执行的权限,他们将被移除. u+x,go=rw 给文件拥有着执行权限并给组和其他人读和执行的权限.多种设定可以用逗号分开. 8.4. umask设置默认权限当创建一个文件时,umask命令控制着文件的默认权限.umask命令使用八进制表示法来表达从文件模式属性中删除一个位掩码.一个八进制的权限掩码用三位数字来表示,但是umask用四位数字来表示.这是因为除了读取,写入和执行权限之外,还有其他较少用到的权限设置. setuid(八进制4000),当应用到一个可执行文件时,它把有效的用户ID从真正的用户设置成程序所有者ID.当一个普通用户运行一个程序,这个程序由根用户所有,并且设置了setuid位,这个程序运行时具有超级用户的特权,这样程序就可以访问普通用户禁止访问的文件和目录. setgid位(八进制2000),把有效用户组ID从真正的用户组ID梗概为文件所有者的组ID.如果设置了一个目录的setgid位,则目录中新创建的文件具有这个目录用户组的所有权,而不是文件创建者所属用户组的所有权. sticky位(八进制1000),他可以把一个可执行文件标志为”不可交换的”.在linux中,会忽略文件的sticky位,但是如果一个目录设置了sticky位,那么它能组织用户删除或重命名文件,除非用户是这个目录的所有者或文件所有者,或超级用户. chmod u+s program 授予一个程序setuid权限 chmod g+s dir 授予一个目录setgid权限 chmod +t dir 授予一个目录sticky权限 8.5. 更改身份su 以其他用户身份和组ID运行一个shell sudo 以另一个用户身份执行命令8.6. chown更改文件所有者和用户组chown [owner][:[group]] file… 8.7. chgrp更改用户组所有权chgrp [group] file… 8.8. 更改用户密码passwd [user] 如果你具有超级用户权限,你可以指定一个用户名作为passwd命令的参数,这样可以设置另一个用户的密码. 9. 进程9.1. 进程是怎样工作的当系统启动的时候,内和先把一些它自己的活动初始化位进程,然后运行一个叫做init的程序.init,依次第,再运行一系列的称为init脚本的shell脚本(位于/etc),它们可以启动所有的系统服务.其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户界面. 在进程方案中,一个程序可以发动另一个程序被表述位一个父进程可以产生一个子进程. 内核维护每个进程的信息,以此来保持事情有序.系统分配给每个进程一个数字,这个数字叫做进程ID或PID.PID号按升序分配,init进程的PID总是1.内和也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程. 9.2. 查看进程 ps 命令查看进程 进程状态表 R 运行中. S 正在睡眠.进程没有运行,而是正在等待一个事件. D 不可中断睡眠.进程正在等待I/O,例:一个磁盘驱动器的I/O T 已停止.已经指示进程停止运行. Z 一个死进程或”僵尸”进程.这是一个已经种植的紫禁城,但是它的父进程没有清空它. &lt; 一个高优先级进程.这会授予一个进程更多重要的资源,给它更多的CPU时间. N 低优先级进程. ps x 展示所有进程 ps aux 这个选项组合,能够显示属于每个用户的进程信息.此命令唤醒”BSD风格”的输出结果. BSD风格ps命令列标题 USER 用户ID.进程的所有者. %CPU 以百分比表示的CPU使用率 %MEM 以百分比表示的内存使用率 VSZ 虚拟内存大小 RSS 进程占用的物理内存的大小,以千字节位单位. START 进程启动的时间.若它的值超过24小时,则用天表示. 9.3. 用top命令动态查看进程“top”这个名字来源于top程序是用来查看系统中”顶端”进程的.top显示结果由两部分组成:最上面是系统概要,下面是进程列表,以CPU的使用率排序. top命令信息字段 行号 字段 意义 1 top 程序名 14:59:20 当前时间. up 6:30 这是正常运行时间. 2users 有两个用户登陆系统 load average: 加载平均值,等待运行的进程数目. 2 Tasks: 总结进程数目和这些进程的状态. 3 Cpu(s): 这一行描述了CPU正在进行的活动特性. 0.7%us 0.7%的CPU被用于用户进程. 1.0%sy 1.0%的CPU时间被用于系统(内核)进程. 0.0%ni 0.0%的CPU时间被用于&quot;nice&quot;(低优先级)进程. 98.3%id 98.3%的CPU时间是空闲的. 0.0%wa 0.0%的CPU时间来等待I/O. 4 Mem: 展示物理内存的使用情况. 5 Swap 展示交换分区(虚拟内存)的使用情况.9.4. 控制进程9.5. 中断一个进程9.6. 把一个进程放置到后台执行为了启动一个程序并让它立即在后台运行,我们在程序命令之后加上”&amp;”字符. 9.7. 进程返回到前台用jobs查看运行的人物,fg命令之后,跟随一个百分号和任务序号(jobspec)就可以了. 9.8. 停止一个进程ctrl-z 可以停止一个进程,非终止它. 用bg命令把程序移到后台. 9.9. Signalskill命令用来终止程序. kill [-signal] PID… 没有指定信号,默认发送TERM(终止)信号. 常用信号 1.HUP 挂起 当一个守护进程受到这个信号,会重新启动并读取配置文件. 2.INT 中断 实现和Ctrl-c一样的功能,由中断发送.通常会终止一个程序. 3.QUIT 退出 9.KILL 杀死 KILL信号从不被发送到目标程序,而是内核立即终止这个进程. 11.SEGV 段错误 如果一个程序非法使用内存,就会发送这个信号. 15.TERM 终止 如果程序仍然”或者”,可以接受信号,那么这个会终止它. 18.CONT 继续 在一个停止信号后,这个信号会恢复进程的运行. 19.STOP 停止 这个信号导致进程停止运行,而不是终止. 20.TSTP 终端停止 当按下Ctrl-z组合键后,终端发送这个信号 28.WINCH 改变窗口大小 当改变窗口大小时,系统会发送这个信号. 例: kill -9 13546 kill -KILL 13546 9.10. 通过killall命令给多个进程发送信号killall [-u user] [-signal] name… 9.11. 更多和进程相关的命令 pstree 输出一个树型结构的进程列表.这个列表展示了进程见父/子关系. vmstat 输出一个系统资源使用快照.包括内存,交换分区和磁盘I/O. xload 一个图形界面程序,可以划出系统负载随时间变化的图形. tload 与xload程序相似,但是在终端画出图形. 10. shell环境 printenv 打印部分或所有的环境变量. set 设置shell选项 export 导出环境变量,让随后执行的程序知道. alias 创建命令别名 10.1. 什么存储在环境变量中 环境变量 shell变量 10.2. 检查环境变量 set 显示shell和环境变量两者 printenv 只显示环境变量 alias 查看别名 10.3. 一些有趣的变量 DISPLAY 通常为”0”,意思是由X产生的第一个显示器. EDITOR 文本编辑器的名字. SHELL shell程序的名字. HOME 用户家目录. LANG 定义了字符集以及语言编码方式. OLD_PWD 先前的工作目录. PAGER 页输出程序的名字.者经常设置为/usr/bin/less. PATH 由冒号分开的目录列表,当输入程序名后,会搜索这个目录列表. PS1 Prompt String 1.这个定义了你的shell提示符的内容. TERM 终端类型名.类Unix的系统支持许多终端协议;这个变量设置你的终端仿真器所用的协议. TZ 制定你所在的时区. USER 你的用户名. 10.4. 如何建立shell环境shell会话类型:登陆shell会话;非登陆shell会话. 登陆shell会读取一个或多个启动文件. 文件 内容 /etc/profile 应用于所有用户的全局配置脚本. ~/.bash_profile 用户私人的启动文件.可用来扩展或重写全局配置脚本中的设置. ~/.bash_login 如果文件~/.bash_profile没有找到.bash会尝试读取这个脚本. ~/.profile 如果~/.bash_profile或文件~/.bash_login都没有找到.bash会试图读取这个文件.这是基于Debian发行版的默认设置.非登陆shell会话会读取以下启动文件: 文件 内容 /etc/bash.bashrc 应用于所有用户的全局配置文件. ~/.bashrc 用户私有的启动文件.可以用来扩展或重写全局配置脚本中的设置.10.5. 一个启动文件的内容以”#”开头的行是注释,shell不会读取它们. PATH变量经常在/etc/profile启动文件中设置. 10.6. 修改shell环境10.7. 我们应该修改哪个文件10.8. 文本编辑器文本编辑器分为两种基本类型:图形化的和基于文本的编辑器. 10.9. 使用文本编辑器nano less vi 10.10. 激活修改source .bashrc 强迫bash重新读取修改过的.bashrc文件 11. vi简介11.1. 学习vivi很多系统都预装.vi是轻量级且执行快速的编辑器. 11.2. vi背景介绍11.3. 启动和停止vi vi 启动vi :q 退出 :q! 强制退出 11.4. 插入模式i按键进入插入模式 11.5. 保存:w 保存修改 11.6. 移动光标 l or 右箭头 向右移动一个字符 h or 左箭头 向左移动一个字符 j or 下箭头 向下移动一行 k or 上箭头 向上移动一行 0(按键) 移动到当前行的行首 ^ 移动到当前行的第一个非空字符. $ 移动到当前行的末尾. w 移动到下一个单词或标点符号的开头 W 移动到下一个单词的开头,忽略标点符号. b 移动到上一个单词或标点符号的开头. B 移动到上一个单词的开头,忽略标点符号 Ctrl-f or Page Down 向下翻一页 Ctrl-b or Page Up 向上翻一页 numberG 移动到第number行. G 移动到文件末尾. 11.7. 基本编辑u按键 命令模式下会撤销卒后一次修改. 11.7.1. 追加文本a 命令模式下光标移动到行为. 11.7.2. 打开一行 o 当前行的下方打开一行. O 当前行的上方打开一行. 11.7.3. 删除文本 x 删除当前字符 3x 删除当前字符及气候的两个字符. dd 删除当前行 5dd 删除当前行及随后的四行文本. dW 删除从光标位置开始到下一个单词的开头. d$ 从光标位置开始到当前行的行尾. d0 从光标位置开始到当前行的行首. d^ 从光标位置开始到文本行的第一个非空字符. dG 从当前行到文件的末尾. d20G 从当前行到文件的第20行. 11.7.4. 剪切,复制和粘贴文本 d 删除的文本被复制到一个粘贴缓冲区 p 将剪切板的文本粘贴到光标位置之后 P 将剪切板中的文本粘贴到光标之前. yy 复制当前行. 5yy 复制当前行及随后的四行文本. yW 复制从当前光标位置到下一个单词的开头. y$ 复制从当前光标位置到当前行的末尾. y0 复制从当前光标位置到行首. y^ 复制从当前光标位置到文本行的第一个非空字符. yG 复制从当前行到文件末尾. y20G 复制从当前行到文件的第20行. 11.8. 查找和替换11.8.1. 查找一行f 查找一行,移动光标到下一个所制定的字符. 例:fa 把光标定位到统一行中下一个出现的&quot;a&quot;字符.通过&quot;;&quot;来重复这个查找.11.8.2. 查找整个文件 / 移动光标到下一个出现的单词或短语上.通过n命令来重复先前的查找. /Line 把光标移动到文件的第一行. 11.8.3. 全局查找和替代:%s/Line/line/gc 把整个文件中的单词”Line”更改为”line” : 冒号字符运行一个ex命令 % 指定要操作的行数.%是个快捷方式,表示从第一行到最后一行.1,5表示从第一行到第五行. 1,$表示从第一行到文件的最后一行. s 指定操作.这种情况是,替换(查找与替代). /Line/line 查找类型与替代文本. g 全局的意思.意味着对文本行中所有匹配的字符串执行查找和替换操作.如果省略g,则只替换每个文本行中第一个匹配的字符串. c 指定一个需要用户确定的替换命令. y 执行替换操作 n 跳过这个匹配的实例 a 对这个及随后所有匹配的字符串执行替换操作. q or esc 退出替换操作. l 执行这次替换并退出.l是”last”简写. Ctrl-e,Ctrl-y 分别是向下滚动和向上滚动.用于查看建议替换的上下文. 11.9. 编辑多个文件vi file1 file2 file3… :n 从一个文件转到下一个文件. :N 回到先前的文件. :buffers 会在屏幕顶部显示一个文件列表. :r file 把指定的文件插入到光标位置之前. 注意:在通过:n或:N命令再由:e命令加载的文件之间切换.这时要使用:buffer命令,气候加上缓冲区号码,来转换文件. 11.10. 保存工作 ZZ 命令模式下输入ZZ就会保存并退出当前文件. :w filename 把文件另存为(文件名) 12. 自定制shell提示符12.1. 解剖一个提示符提示符包含我们的用户名,主机名和当前工作目录.它是由一个环境变量定义的,叫做PS1(prompt string one),可通过echo命令来查看PS1的内容. [me@linuxbox ~]$ echo $PS1 [\\u@\\h \\W]\\$ \\a 以ASCII格式编码的铃声.当遇到这个转义序列时,计算机会发出嗡嗡的响声. \\d 以日,月,天格式来表示当前日期. \\h 本地机的主机名,但不代末尾的域名. \\H 完整的主机名. \\j 运行在当前shell会话中的工作数. \\l 当前终端设备名. \\n 一个换行符. \\r 一个回车符. \\s shell程序名. \\t 以24小时制,hours:minutes:seconds的格式表示当前时间. \\T 以12小时制表示当前时间. @ 以12小时制,AM/PM格式来显示当前时间. \\A 以24小时制,hours:minutes格式表示当前时间. \\u 当前用户名. \\v shell程序的版本号. \\V shell程序的版本号. \\w 当前工作目录名. \\W 当前工作目录名的最后部分. \\! 当前命令的历史号. \\# 当前shell绘画中的命令数. \\$ 这会显示一个”$”字符,除非你拥有超级用户权限. \\[ 标志着一系列一个或多个非打印字符的开始.被用来潜入非打印的控制字符,这些字符以某种方式来操作终端仿真器,比如说移动光标或者是更改文本颜色. \\] 标志着非打印字符序列结束. 12.2. 一些可替代的提示符设计 ps1_old=”$PS1” 备份变量 PS1=”[\\u@\\h@\\s\\n\\t \\W $]” 编辑变量PS1 PS1=”$ps1_old” 12.3. 添加颜色字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI 转义编码来控制的。这个控制编码不会“打印”到屏幕上,而是被终端解释为一个指令。’[‘ 和 ‘]’ 序列被用来封装这些非打印字符。一个 ANSI 转义编码以一个八进制 033(这个编码是由退出按键产生的)开头,其后跟着一个可选的字符属性,在之后是一个指令。 \\033[0;30m] Black \\033[1;30m] Dark Gray \\033[0;31m] Red \\033[1;31m] Light Red \\033[0;32m] Green \\033[1;32m] Light Green \\033[0;33m] Brown \\033[1;33m] Yellow \\033[0;34m] Blue \\033[1;34m] Light Blue \\033[0;35m] Purple \\033[1;35m] Light Pur-ple \\033[0;36m] Cyan \\033[1;36m] Light Cyan \\033[0;37m ] Light Gray \\033[1;37m] White 例:PS1=”[\\033[0;31m]&lt;\\u@\\h@\\s\\n\\t \\W \\$\\033[0m” 用转义序列来设置背景颜色 \\033[0;40m 蓝色 \\033[1;44m 黑色 \\033[0;41m 红色 \\033[1;45m 粉红 \\033[0;42m 绿色 \\033[1;46m 青色 \\033[0;43m 棕色 \\033[1;47m 浅灰色 例:PS1=’\\[\\033[0;41m\\]&lt;\\u@\\h \\W&gt;$\\[\\033[0m\\] ‘ 注意:除了正常的 (0) 和黑体 (1) 字符属性之外,文本也可以具有下划线 (4),闪烁 (5),和反向 (7) 属性。为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性。 12.4. 移动光标 \\033[1;cH 把光标移动第一行,第C列. \\033[nA 把光标向上移动n行. \\033[nB 把光标向下移动n行. \\033[nC 把光标向前移动n个字符. \\033[nD 把光标向后移动n个字符. \\033[2J 清空屏幕,把光标移到左上角(第0行,第0列). \\033[K 清空从光标位置到当前行末的内容. \\033[s 存储当前光标位置. \\033[u 唤醒之前存储的光标位置. 例:PS1=’[\\033[s\\033[0;0H\\033[0;41m\\033[K\\033[1;33m\\t\\033[0m\\033[u]&lt;\\u@\\h \\W&gt;$ ‘ [ 开始一个非打印字符序列.其真正的目的是为了让bash能够正确第计算提示符的大小.如果没有这个转义字符的话,命令行编辑功能会弄错光标的位置. \\033[s 存储光标位置.这个用来使光标能回到原来提示符的位置.当长条和时钟显示到屏幕上方之后.当心一些终端仿真器不推崇这个编码. \\033[0;0H 把光标移到屏幕左上角,也就是第0行,第0列的位置. \\033[0;41m 把背景设置为红色. \\033[1;33m 把文本颜色设为黄色. \\t 显示当前时间.虽然这是一个可”打印”的元素,但我们仍把它包含在提示符的非打印部分,因为我们不想bash在计算可见提示符的真正大小时包含这个时钟在内. \\033[0m 关闭颜色设置.这对文本和背景都起作用. \\033[u 恢复到之前保存过的光标位置处. ] 结束非打印字符序列. &lt;\\u@\\h\\W&gt;$ 提示符字符串. 12.5. 保存提示符PS1=&apos;\\[\\033[s\\033[0;0H\\033[0;41m\\033[K\\033[1;33m\\t\\033[0m\\033[u\\]&lt;\\u@\\h \\W&gt;\\$ &apos;13. 软件包管理Linux发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性. 13.1. 打包系统 Debian Style(.deb) Debian,Ubuntu,Xandros,Linspire Red Hat Style(.rpm) Fedora,Centos,Red Hat Enterprise Linux,OpenSUSE,Mandriva,PCLinuxOS 13.2. 软件包管理系统工作原理13.3. 包文件包文件是一个构成软件包的文件压缩集合.一个软件包可能由大量程序以及支持这些程序的数据文件组成.另外,许多软件包还包含预安装和安装后脚本. 13.4. 资源库软件项目选择执行他们自己的打包和发布策略,但是现在大多数软件包是由发行商和感兴趣的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包,这个资源库可能包含了成千上万个软件包,每一个软件包都是专门为这个系统发行版建立和维护的。 13.5. 依赖性程序很少是”孤立的”,而是依赖于其它软件组件来完成它们的工作. 13.6. 上层和底层软件包工具软件包管理系统通常由两种工具类型组成: 底层工具用来处理这些任务,如安装和删除软件包文件. 上层工具用来完成元数据搜索和依赖解析. 13.7. 常见软件包管理任务13.8. 查找资源库中的软件包使用上层工具来搜索资源库元数据,可以根据软件包的名字和说明来定位它. 风格 命令 Debian apt-get update;apt-cache search search_string Red Hat dnf search search_string 例:dnf search emacs 通过dnf资源库来查找emacs文本编辑器.13.9. 从资源库中安装一个软件包上层工具允许从一个资源库中下载一个软件包,并经过完全依赖解析来安装它. 13.10. 通过软件包文件来安装软件如果从某处而不是从资源库中下载了一个软件包文件,可以使用底层工具来直接(没有经过依赖解析)安装它. 底层软件包安装命令 风格 命令 Debian dpkg --install package_file Red Hat rpm -i package_file注意:因为这项技术使用底层的rpm程序来执行安装任务,所以没有运行依赖解析.如果rpm程序发现缺少了一个依赖,则会报错并退出. 13.11. 卸载软件可以使用上层或者底层工具来卸载软件. 上层工具卸载命令: 风格 命令 Debian apt-get remove package_name Red Hat yum erase package_name13.12. 经过资源库来更新软件包软件包更新命令 风格 命令 Debian apt-get update;apt-get upgrade Red Hat yum update13.13. 经过软件包文件来升级软件可以安装非资源库网站下载的软件包最新版,用它来替代先前的版本. 底层软件包升级命令 风格 命令 Debian dpkg –install package_file Red Hat rpm -U package_file 例:rpm -U emacs-22.1-7.fc7-i386.rpm注意:rpm程序安装一个软件包和升级一个软件包所用的选项是不同的,而dpkg程序所用的选项是相同的. 13.14. 列出所安装的软件包风格 命令 Debian dpkg --list Red Hat rpm -qa13.15. 确定是否安装了一个软件包软件包状态命令 风格 命令 Debian dpkg –status package_name Red Hat rpm -q package_name 13.16. 显示所安装软件包的信息查看软件包信息命令 风格 命令 Debian apt-cache show package_name Red Hat yum info package_name 13.17. 查找安装了某个文件的软件包文件识别命令 风格 命令Debian dpkg –search file_nameRed Hat rpm -qf file_name 14. 存储媒介 mount 挂载一个文件系统 umount 卸载一个文件系统 fsck 检查和修复一个文件系统 fdisk 分区表控制器 mkfs 创建文件系统 fdformat 格式化一张软盘 dd 把面向块的数据直接写入设备 genisoimage(mksiofs) 创建一个ISO 9660 的映像文件 wodim(cdrecord) 把数据写入光存储媒介 md5sum 计算MD5检验码 14.1. 挂载和卸载存储设备文件/etc/fstab列出系统启动时要挂载的设备./etc/fstab字段. 字段 内容 说明 1 设备名 一般这个字段包含与物理设备相关联的设备文件的实际名字. 2 挂载点 设备所连接到的文件系统树的目录. 3 文件系统类型 linux允许挂载许多文件系统类型. 4 选项 文件系统可以通过各种选项来挂载. 5 频率 一位数字,指定是否和在什么时间用dump命令来备份一个文件系统. 6 次序 一位数字,指定fsck命令按照什么次序来检查文件系统.14.2. 查看挂载的文件系统列表使用mount命令来挂载文件系统.执行这个不带参数的命令,将会显示一系列当前挂载的文件系统. 14.3. 确定设备名称Linux存储设备名称 /dev/fd* 软盘驱动器/dev/hd* 老系统中的IDE(PATA)磁盘.典型的主板包含两个IED连接器或者是通道,每个连接器带有一根缆线,每根缆线上有来两个硬盘驱动器连接点.缆线上的第一个驱动器叫做主设备,第二个叫做从设备./dev/lp* 打印机/dev/sd* SCSI磁盘.在最近的linux系统中,内核把所有类似于磁盘的设备看作SCSI磁盘./dev/sr* 光盘(CD/DVD)读取器和烧写器. 14.4. 创建新的文件系统14.5. 用fdisk命令操作分区fdisk程序允许直接在底层与类似磁盘的设备进行交互.使用这个工具可以在设备上编辑,删除和创建分区. 例:U盘 sudo umount /dev/sdb1 卸载U盘 sudo fdisk /dev/sdb 启动程序fdisk m 显示程序菜单 p 打印出设备的分区表 l 显示一个很长的可能类型列表 b 已存在分区类型的ID号 83 针对linux系统的ID号 14.6. 用mkfs命令创建一个新的文件系统mkfs(make file system 的简写),它能创建各种格式的文件系统. 14.7. 测试和修复文件系统fsck(fle system check 的简写). fsck修复受损的文件系统. fsck检查文件系统的完整性.每个/etc/fstab项中的最后一个数字指定了设备的检查顺序.数字为0则相应设备不会被检查. fsck修复受损的文件系统.其成功率依赖于受损怀的数量. 14.8. 格式化 sudo fdformat /dev/fd0 sudo mkfs -t msdos /dev/fd0 1.14.9. 直接把数据移入/出设备dd程序可以把数据块从一个地方复制到另一个地方. dd if=input_file of=output_file [bs=block_size[count=blocks]] 例: dd if=/dev/sdb of=/dev/sdc dd if=/dev/sdb of=flash_drive.img警告:dd命令非常强大.虽然它的名字来自于”数据定义”,有时候也把它叫做”清除硬盘”.因为用户经常会误输入if或of的规范. 14.10. 创建CD-ROM映像写入一个CD-ROM 构建一个ISO映像,这就是一个CD-ROM的文件系统映像. 把这个映像文件写入到CD-ROM媒介中. 14.10.1. 创建一个CD-ROM的映像拷贝dd if=/dev/cdrom of=ubuntu.iso这项技术也适用于DVD光盘,但不能用于音频CD,因为它们不是用文件系统来存储数据.(音频CD,看一下cdrdao命令). 14.10.2. 从文件集中创建一个映像创建一个包含目录内容的iso映像文件,使用genisoimage程序. 创建一个包含所有文件的目录. 执行genisoimage来创建映像文件. 例: genisoimage -o cd-rom.iso -R -J -/cd-rom-files -R 选项添加元数据为Rock Ridege扩展,这允许使用长文件名和POSIX风格的文件权限. -J 选项使Joliet扩展生效.这样Windows就支持长文件名了. 14.11. 写入CD-ROM镜像14.11.1. 直接挂载一个ISO镜像 mkdir /mnt/iso_image mount -t iso9660 -o loop image.iso /mnt/iso_image 添加”-o loop”选项来挂载(同时带有必需的”-t iso9660”文件系统类型),挂载这个映像文件就好像它是一台设备,把它连接到文件系统树上.这样就创建了一个挂载点叫做/mnt/iso_image,然后把此映像文件image.iso挂载到挂载点上. 14.12. 清楚一张可重写入的CD-ROMwodim dev=/dev/cdrw blank=fast使用wodim命令,指定设备名称和清空的类型. 14.13. 写入镜像wodim dev=/dev/cdrw image.isowodim命令的默认模式是track-at-once,这对于录制音乐很有用.-v 详细输出-dao 以disk-at-once模式写入光盘. md5sum image.iso当使用md5sum程序时,它会产生一个独一无二的十六进制数字. 15. 网络系统 ping 发送ICMP ECHO_REQUEST软件包到网络主机. traceroute 打印到一台网络主机的路由数据包. netstat 打印网络连接,路由表,接口统计数据,伪装连接和多路广播成员. ftp 因特网文件传输程序. wget 非交互式网络下载器. ssh OpenSSH SSH 客户端(远程登录程序). 15.1. 检查和检测网络15.2. pingping命令发送一个特殊的网络数据包,叫做IMCP ECHO_REQUEST,到一台指定的主机.大多数接收这个包的网络设备将会回复它,来允许网络连接验证. 注意:大多数网络设备(包括Linux主机)都可以被配置为忽略这些数据包.通常,这样做是处于网络安全原因,部分地遮蔽一台主机免受一个潜在攻击者地侵袭.配置防火墙来阻塞IMCP流量很普遍. 15.3. traceroutetraceroute程序(有些系统使用相似的tracepath程序来替代)会显示从本地到指定主机要经过的所有”跳数”的网络流量列表.对于那些提供标识信息的路由器,我们能看到它们的主机名,IP地址和性能数据,这些数据包括三次从本地到此路由器的往返时间样本.对于没有提供标识信息的路由器(由于路由器配置,网络拥塞,防火墙等方面的原因),我们会看到几个星号. 15.4. netstatnetstat程序被用来检查各种各样的网络位置和统计数据. -ie 查看系统中的网络接口. eth0 因特网接口 lo 内部回环网络虚拟接口.系统用它来”自言自语”. UP 每个网络接口第四行开头出现的”UP”,说明这个网络接口已经生效. DHCP 对于使用DHCP的系统,在这个地段中的一个有效IP地址则证明DHCP工作正常. -r 显示内核的网络路由表. 15.5. 网络中传输文件15.5.1. ftpFTP被广泛地用来从因特网上下载文件.大多数网络浏览器都支持FTP.FTP的原始形式并不是安全的,因为它会以明码形式发送账号的姓名和密码. ftp fileserver 唤醒ftp程序,让它连接到FTP服务器,file-server anonymous 登陆名. cd pub/cd_images/Ubuntu-8.04 跳转到远端系统中,要下载的文件所在目录下. ls 列出远端系统中的目录. lcd Desktop 跳转到本地系统中的~/Desktop目录下 get ubuntu-8.04-desktop-i386.iso 告诉远端系统传诵文件到本地 bye 退出远端系统服务器,结束ftp程序会话.ftp&gt;提示符下,输入”help”会显示所支持命令的列表. 15.6. lftp 更好的ftpftp并不是唯一的命令行形式的FTP客户端.lftp是比较流行的ftp程序. 15.7. wget从网络和FTP网站下载数据. 15.8. 与远程主机安全通信rlogin和telnet程序拥有和ftp程序一样的知名缺点:它们以明码形式来传输所有的交流信息. 15.8.1. 1一款新的协议SSH(Secure Shell)解决了这两个基本的和远端主机安全交流的问题. SSH认证远端主机是否为它所知道的那台主机.这样就组织了所谓的”中间人”的攻击. SSH加密了本地与远程主机之间所有的通讯信息. SSH由两部分组成. SSH服务器运行在远端主机,在端口号22上监听将要到来的连接. SSH客户端用在本地系统中,用来和远端服务器通信. 15.9. scp 和 sftpOpenSSH软件包也包含两个程序,它们可以利用SSH加密通道在网络间复制文件. scp(安全复制)被用来复制文件,与熟悉的cp程序非常相似.最显著的区别就是源或者目标路径名要以远端主机的名后跟着一个冒号字符开头. 例:scp remote-sys:document.txt 从远端系统remote-sys的家目录下复制文档document.txt到我们本地系统的当前工作目录下. sftp是ftp程序的安全替代品.sftp工作起来与我们之前使用的ftp程序很相似,然而它不用明码形式来传递数据,它使用加密的SSH通道. 16. 查找文件locate 通过名字来查找文件 find 在目录层次结构中搜索文件 xargs 从标准输入生成和执行命令行 touch 更改文件时间 stat 显示文件或文件系统状态16.1. locate 查找文件的简单方法locate程序快速搜索路径名数据库,并且输出每个与给定字符串相匹配的文件名. 例:locate /bin/zip locate 命令将会搜索它的路径名数据库,输出任一个包含字符串“bin/zip”的路径名.16.2. find 查找文件的复杂方式find程序能基于各种各样的属性,搜索一个给定目录来查找文件. 16.2.1. Tests例: find ~ -type d | wc -l 输出家目录列表 find ~ -type f | wc -l 输出家目录下的普通文件find文件类型 文件类型 描述 b 块设备文件 c 字符设备文件 d 目录 f 普通文件 l 符号链接 例:find ~ -type f -name &quot;\\*.JPG&quot; -size +1M | wc -l 加入 -name 测试条件,后面跟通配符模式.双引号用来组织shell展开路径名.加入-size测试条件,后跟&quot;+1M&quot;,开头的加号表明我们正在寻找文件大小大于指定数的文件.若字符串以减号开头,则意味着查找小于指定数的文件.若没有符号意味着&quot;精确匹配这个数&quot;.结尾字母&quot;M&quot;表明测量单位是兆字节.find大小单位 字符 单位 b 512个字节块.默认值. c 字节 w 两个字节的字 k 千字节(1024个字节单位) M 兆字节(1048576个字节单位) G 千兆字节(1073741824个字节单位)find测试条件 测试条件 描述 -cmin n 匹配的文件和目录的内容或属性最后修改时间正好在n分钟之前.指定少于n分钟之前,使用-年,指定多于n分钟之前,使用+n. -cnewer file 匹配的文件和目录的内容或属性最后修改时间早于那些文件. -ctime n 匹配的文件和目录的内容和属性最后修改时间在n\\*24小时之前. -empty 匹配空文件和目录. -group name 匹配的文件和目录属于一个组.组可以用组名或组ID来表示. -iname pattern 就像-name测试条件,但是不区分大小写. -inum n 匹配的文件的inode号是n.这对于找到某个特殊inode的所以有硬链接很有帮助. -mmin n 匹配的文件或目录的内容被修改于n分钟之前. -mtime n 匹配的文件或目录的内容被修改于n\\*24小时之前. -name pattern 用指定的通配符模式匹配的文件和目录. -newer file 匹配的文件和目录的内容早于指定的文件.当编写shell脚本,做文件备份时,非常有帮助.每次你制作一个备份,更新文件,然后使用find名来来决定自赏赐更新,哪一个文件已经更改了. -nouser 匹配的文件和目录不属于一个有效的用户. -perm mode 匹配的文件和目录的权限已经设置为指定的mode. -samefile name 相似于-inum测试条件.匹配和文件name享有同样inode号的文件. -size n 匹配的文件大小为n. -user name 匹配的文件或目录属于某个用户.这个用户可以通过用户名或用户ID来表示.find命令手册有更详细的说明. 16.3. 操作符find命令的逻辑操作符 -and 如果操作符两边的测试条件都是真,则匹配.可以简写为-a.注意若没有使用操作符,则默认使用-and. -or 若操作符两边的任一个测试条件为真,则匹配.可以简写为-o. -not 若操作符后面的测试条件是真,则匹配.可以简写为一个感叹号(!). () 把测试条件和操作符组合起来形成更更大的表达式.这用来控制逻辑计算的优先级.默认情况下,find命令按照从左到右的顺序计算. 16.4. 预定以的操作几个预定义的find命令操作 -delete 删除当前匹配的文件. -ls 对匹配的文件执行等同的ls -dils命令.并将结果发送到标准输出. -print 把匹配文件的全路径名输送到标准输出.如果没有指定其它操作,这是默认操作. -quit 一旦找到一个匹配,退出. 例:find ~ find ~ -print find ~ -type f -name &apos;*.BAK&apos; -delete find ~ -type f -name &apos;*.BAK&apos; -print find ~ -type f -and -name &apos;*.BAK&apos; -and -print 16.5. 用户定义的行为-exec command{}这里的command就是指一个命令的名字,{}是当前路径名的符号表示,分号是要求的界定符表明命令结束. 例:find ~ -type f -name &apos;foo*&apos; -ok ls -l &apos;{}&apos; &apos;;&apos; 花括号和分号对于 shell 有特殊含义,所以它们必须被引起来或被转义。 在这个例子里面,我们搜索以字符串“foo”开头的文件名,并且对每个匹配的文件执行 ls-l 命令。通过使用 -ok 行为来代替 -exec,会在 ls 命令执行之前提示用户。 16.6. 提高效率当 -exec 行为被使用的时候,若每次找到一个匹配的文件,它会启动一个新的指定命令的实例。我们可能更愿意把所有的搜索结果结合起来,再运行一个命令的实例。 例:find ~ -type f -name &apos;foo*&apos; -exec ls -l &apos;{}&apos; &apos;;&apos; 通过把末尾的分号改为加号,就激活了 find 命令的一个功能,把搜索结果结合为一个参数列表,然后执行一次所期望的命令。 例:find ~ -type f -name &apos;foo*&apos; -exec ls -l &apos;{}&apos; +16.7. xargsxargs命令会执行一个有趣的函数.它从标准输入接受输入,并把输入转换为一个特定命令的参数列表.注意:当被放置到命令行中的参数个数相当大时,参数个数是有限制的.有可能创建的命令太长以至于shell不能接受.当命令行超过系统支持的最大长度时,xargs会执行带有最大参数个数的指定命令,然后重复这个过程直到耗尽标准输入.执行带有-show-limits选项的xargs命令,来查看命令行的最大值. 例:find ~ -type f -name &apos;foo\\*&apos; -print | xargs ls -l16.8. 返回操练场16.9. 选项find命令选项 -depth 指导find程序先处理目录中的文件,再处理目录自身.当指定-delete行为时,会自动应用这个选项. -maxdepth levels 当执行测试条件和行为的时候,设置find程序陷入目录树的最大级别数. -mindepth levels 在应用测试条件和行为之前,设置find程序陷入目录数的最小级别数. -mount 指导find程序不要搜索挂载到其它文件系统上的目录. -noleaf 指导find程序不要基于搜索雷Unix的文件系统做出的假设,来优化它的搜索. 17. 归档和备份文件压缩程序: gzip 压缩或者展开文件 bzip2 块排序文件压缩器 归档程序: tar 磁带打包工具 zip 打包和压缩文件 文件同步程序: rsync 同步远端文件和目录 17.1. 压缩文件数据压缩就是一个删除冗余数据的过程.压缩算法分为两大类,无损压缩和有损压缩. 17.1.1. gzipgzip程序被用来压缩一个或多个文件.当执行gzip命令时,则原始文件的压缩版会替代原始文件.gunzip程序被用来把压缩文件复原为没有被压缩的版本. gzip选项 -c 把输出写入到标准输出,并且保留原始文件.也可能用–stdout和–to-stdout选项来指定. -d 解压缩.正如gunzip命令一样.也可以用–decompress或者–uncompress选项来指定. -f 强制压缩,即使原始文件的压缩文件已经存在了,也要执行.也可以用–force选项来指定. -h 显示用法信息.也可以用–help选项来指定. -l 列出每个被压缩文件的压缩数据.也可用–list选项. -r 若命令的一个或多个参数是目录,则递归第压缩目录中的文件.也可以用–recursive选项来指定. -t 测试压缩文件的完整性.也可以用–test选项来指定. -v 显示压缩过程中的信息.也可以用–verbose选项来指定. -number 设置压缩指数.number是一个在1(最快,最小压缩)到9(最慢,最大压缩)之间的整数.数值1和9也可以各自用–fast和–best选项来表示.默认值是整数6. 17.1.2. bzip2bzip2程序使用了不同的压缩算法,舍弃了压缩速度,而实现了更高的压缩级别.bzip2 程序使用起来和 gzip 程序一样。我们之前讨论的 gzip 程序的所有选项(除了 -r),bzip2 程序同样也支持。注意,然而,压缩级别选项(-number)对于bzip2 程序来说,有少许不同的含义。伴随着 bzip2 程序,有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序,其会试图恢复受损的.bz2 文件。 17.2. 归档文件归档就是手机许多文件并把它们捆绑成一个大文件的过程. 17.2.1. tartar(tape archive的简称)是一款制作磁带备份的工具.而它仍然被用来完成传统任务,它也同样适用于其它的存储设备.”.tar”表示普通的tar包.”.tgz”表示被gzip程序压缩过的tar包. tar mode[options] pathname...部分tar的mode c 为文件和/或目录列表创建归档文件. x 抽取归档文件. r 追加具体的路径到归档文件的末尾. t 列出归档文件的内容. 17.3. zipzip程序既是压缩工具,也是打包工具. zip options zipfile file... 例: zip -r playground.zip playground unzip ../playground.zip unzip -l playground.zip playground/dir-87/file-ZArchive: ../playground.zip对于zip命令要注意一点,就是如果制定了一个已经存在的文件包,其被更新而不是被替代.这意味着就保留此文件包,但是会添加新文件,同时替换匹配的文件. 17.4. 同步文件和目录rsync option source destination 这里source和destination是下列选项之一: 一个本地文件或目录 一个远端文件或目录,以[user@]host:[path的形式存在 一个远端rsync服务器,由rsync://[user@]host[:port]/path指定 注意source和destination两者之一必须是本地文件.rsync不支持远端到远端的复制. 18. 正则表达式正则表达式是一种符号表示法,被用来识别文本模式.在某种程度上,他们与匹配文件和路径名的shell通配符比较相似,但其规模更庞大. 18.1. grepgrep(global regular expression print的简写). grep [options] regex [file...]这里的regx是指regular expression,一个正则表达式. 常用的grep选项列表: -i 忽略大小写.不会区分大小写字符.也可用–ignore-case来指定. -v 不匹配.通常,grep程序会打印包含匹配项的文本行.这个选项导致grep程序只会不包含匹配项的文本行.也可以使用–invert-match指定. -c 打印匹配的数量(或者是不匹配的数目,若指定了-v选项),而不是文本行本身.也可用–count选项来指定. -l 打印包含匹配项的文件名,而不是文本行本身,也可用–files-with-matches选项来指定. -L 相似于-l选项,但是只是打印不包含匹配项的文件名.也可用–files-without-match来指定. -n 在么哥匹配行之前大引出其位于文件中的相应行号.也可用–line-number选项来指定. -h 应用于多文件搜索,不输出文件名.可用–no-filename选项来指定. 18.2. 元字符和文本正则表达式元字符由 ^ $ . [ ] { } - ? * + ( ) | \\ 组成.然后其它所有字符都被认为是原义字符,虽然在个别情况下,反斜杠会被用来创建元序列,也允许元字符被转义为原义字符,而不是被解释为元字符。 18.3. 任何字符圆点字符被用来匹配任意字符.如果我们在正则表达式中包含它,它将会匹配在此位置的任意一个字符. 例:grep -h ‘.zip’ dirlist*.txt 18.4. 锚点在正则表达式中,插入符号和美元符号被看作是锚点.这意味着正则表达式只有在文本行的开头或末尾被找到时,才算发生一次匹配. 例:grep -h &apos;^zip&apos; dirlist*.txt grep -h &apos;zip$&apos; dirlist*.txt grep -h &apos;^zip$&apos; dirlist*.txt grep -i &apos;^..j.r$&apos; /usr/share/dict/words18.5. 中括号表达式和字符类通过使用中括号表达式,我们也能够从一个指定的字符集合中匹配一个单个的字符.通过中括号表达式,我们能够制定一个字符集合(包含在不加中括号的情况下会被解释为元字符的字符)来被匹配.一个字符集合包含任意多个字符,并且元字符被放置到中括号里面会失去它们的特殊含义.然而,在良好宗情况下,会在中括号表达式中使用元字符,并且有着不同的含义.第一个元字符是插入字符,其被用来表示否定;第二个是连字符字符,其被用来表示一个字符区域. 18.6. 否定通过在正则表达式中的第一个字符为插入字符”^”,则剩余的字符被看作是不会在给定的字符位置出现的字符集合. grep -h &apos;[^bg]zip&apos; dirlist*.txt 通过激活否定操作得到文件列表.否定的字符集仍然在给定位置要求一个字符,但是这个字符必须不是否定字符集的成员.18.7 传统的字符区域通过使用一个三字符区域,我们能够所写26个字母.任意字符的区域都能按照这种方式表达,包括多个区域,如字母和数字. grep -h &apos;^[A-Za-z0-9]&apos; dirlist*.txt 例:grep -h &apos;[A-Z]&apos; dirlist*.txt 这会匹配包含一个大写字母的文件名. grep -h &apos;[-AZ]&apos; dirlist*.txt 这个表达式会匹配包含一个连字符,或一个大写字母&quot;A&quot;,或一个大写字母&quot;Z&quot;的文件名.18.8 POSIX 字符集POSIX 字符集 字符集 说明 [:alnum:] 字母数字字符.在ASCII中,等价于:[A-Za-z0-9] [:word:] 与[:alnum:]相同,但增加了下划线字符. [:alpha:] 字母字符.在ASCII中,等价于:[A-Za-z] [:blank:] 包含空格和tab字符. [:cntrl:] ASCII的控制码.包含了0到31,和127的ASCII字符. [:digit:] 数字0-9 [:graph:] 可视字符.在ASCII中,它包含33到126的字符. [:lower:] 小写字母. [:punct:] 标点符号字符.在ASCII中,等价于: [:print:] 可打印的字符.在[:graph:]中的所有字符,再加上空格字符. [:space:] 空白字符,包含空格,tab,回车,换行,vertical tab,和form feed.在ASCII中,等价于:[\\t\\r\\n\\v\\f] [:upper:] 大写字母. [:xdigit:] 用来表示十六进制数字的字符.在ASCII中,等价于:[0-9A-Fa-f] 例: [me@linuxbox ~]$ ls /usr/sbin/[A-Z]* ls /usr/sbin/[[:upper:]]*18.9 POSIX基本的Vs.扩展的正则表达式POSIX把正则表达式的实现分成了两类:基本正则表达式(BRE)和扩展的正则表达式(ERE).BRE辨别以下元字符: ^ $ . [ ] * 其它的所有字符被认为是文本字符.ERE添加了以下元字符(以及与其相关的功能): ( ) { } ? + | 在BRE中,字符”(“,”)”,”{“,”}”用反斜杠转义后,被看作是元字符,相反在ERE中,在任意元字符之前加上反斜杠会导致其被看作是一个文本字符. 18.10 Alternation扩展表达式的特性之一alternation(交替).它允许从一系列字符串或者是其它的正则表达式中选择匹配项. 例: echo &quot;AAA&quot; | grep -E &apos;AAA|BBB&apos;这里的正则表达式’AAA|BBB’,意味着”匹配字符串AAA或者是字符串BBB”.注意因为这是一个扩展的特性,我们给grep命令(虽然我们能以egrep程序来代替)添加了-E选项,并且我们把这个正则表达式用单引号引起来,为的是阻止shell把竖杠线元字符解释为一个pipe操作符.Alternation并不局限于两种选择:echo “AAA” | grep -E ‘AAA|BBB|CCC’ 为了把 alternation 和其它正则表达式元素结合起来,我们可以使用 () 来分离 alternation。 例:grep -Eh &apos;^(bz|gz|zip)&apos; dirlist*.txt这个表达式将会在我们的列表中匹配以“bz”,或“gz”,或“zip”开头的文件名。如果我们删除了圆括号,这个表达式的意思:grep -Eh ‘^bz|gz|zip’ dirlist*.txt .会变成匹配任意以“bz”开头,或包含“gz”,或包含“zip”的文件名。 18.11 限定符扩展的正则表达式支持几种方法,来指定一个元素被匹配的次数. 18.11.1 ? 匹配零个或一个元素这个限定符意味着,实际上,”使前面的元素可有可无”. 18.11.2 * 匹配零个或多个元素这个限定符被用来表示一个可选的字符,匹配的字符可以出现任意多次,不仅是一次. [[:upper:]][[:upper:][:lower:] ]*.这个表达式由三个元素组成:一 个 包 含 [:upper:] 字 符 集 的 中 括 号 表 达 式,一 个 包 含[:upper:] 和 [:lower:] 两个字符集以及一个空格的中括号表达式,和一个被反斜杠字符转义过的圆点。第二个元素末尾带有一个 * 元字符,所以在开头的大写字母之后,可能会跟随着任意数目的大写和小写字母和空格,并且匹配. 例: echo &quot;This works.&quot; | grep -E &apos;[[:upper:]][[:upper:][[:lower:]]*.&apos;18.11.3 + - 匹配一个或多个元素这个+元字符的作用与*相似,除了它要求前面的元素至少出现一次匹配.这个正则表达式只匹配那些由一个或多个字母字符组构成的文本行,字母字符之间由单个空格分开: 18.11.4 { } 匹配特定个数的元素{ 和 } 元字符被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定: 限定符 意思 n 匹配前面的元素,如果它确切地出现了n次. n,m 匹配前面的元素,如果它至少出现了n次,但是不多于m次 n, 匹配前面的元素,如果它出现了n次或多于n次. ,m 匹配前面的元素,如果它出现的次数不多于m次. 例: ^\\(?[0-9][0-9][0-9]\\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$ 简化为: ^\\(?[0-9]{3}\\)? [0-9]{3}-[0-9]{4}$ grep -Ev &apos;^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$&apos; 这里我们使用 -v 选项来产生相反的匹配,因此我们将只输出不匹配指定表达式的文本行。这个表达式自身的两端都包含定位点(锚)元字符,是为了确保这个号码的两端没有多余的字符。这个表达式也要求圆括号出现在一个有效的号码中,不同于我们先前电话号码的实例。 18.12 用find查找文件名当某一行包含的字符串匹配上了一个表达式的时候,grep 命令会打印出这一行,然而 find 命令要求路径名精确地匹配这个正则表达式。 例:find . -regex &apos;.*[^-\\_./0-9a-zA-Z].*&apos;这样一种扫描会发现包含空格和其它潜在不规范字符的路径名.由于要精确地匹配整个路径名,所以我们在表达式的两端使用了.*,来匹配零个或多个字符。在表达式中间,我们使用了否定的中括号表达式,其包含了我们一系列可接受的路径名字符。 18.13 用locate查找文件这个 locate 程序支持基本的(–regexp 选项)和扩展的(–regex 选项)正则表达式。 例:locate --regex &apos;bin/(bz|gz|zip)&apos;通过使用 alternation,我们搜索包含 bin/bz,bin/gz,或/bin/zip 字符串的路径名。 18.14 在less和vim中查找文本less 和 vim 两者享有相同的文本查找方法。按下/按键,然后输入正则表达式,来执行搜索任务。 例:/^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$1.19 文本处理 cat 连接文件并且打印到标准输出 sort 给文本行排序 uniq 报告或者省略重复行 cut 从每行中删除文本区域 paste 合并文件文本行 join 基于某个共享字段来联合两个文件的文本行 comm 逐行比较两个有序文件. diff 逐行比较文件 patch 给原始文件打补丁 tr 翻译或删除字符 sed 用于筛选和转换文本的流编辑器 aspell 交互式拼写检查器 19.1 文本应用程序vim | nano | less | 19.1.1 文档一个流行的方法是先用文本格式来编写一个大的文档,然后使用一种标记语言来描述已完成文档的格式. 19.1.2 网页HTML | XML 19.1.3 电子邮件通过下载一个email信息,用less来浏览它.开始于标题,其描述信息的来源及传输过程中接受到的处理,然后是信息的正文内容. 19.1.4 打印输出输出会以纯文本格式发送到打印机,或者如果页面包含图形,其会被转换成一种文本格式的页面描述语言. 19.1.5 程序源码程序源代码,程序员实际编写的一部分程序,总是文本格式. 19.2 回顾一些老朋友19.2.1 cat19.2.2 sortsort程序能接受命令行中的多个文件作为参数,所以有可能把多个文件合并成一个有序的文件. 19.2.3 uniquniq会删除任意重复行,并且把结果发送到标准输出.它常常和sort程序一块使用,来清理重复的输出. 19.3 切片和切块19.3.1 cutcut程序被用来从文本行中抽取文本,并把其输出到标准输出.它能接受多个文件参数或者标准输入. 19.3.2 pastepaste命令会添加一个或多个文本列到文件中,而不是从文件中抽取文本列. 19.3.3 join一个join操作通常与关系型数据库有关联,在关系型数据库中来自多个享有共同关键域的表哥的数据结合起来,得到一个结果. 1.20 比较文本20.1 commcomm程序会比较两个文本文件,并且会显示每个文件特有的文本行和共有的文本行. 20.2 diffdiff程序被用来检测文件之间的差异.它支持许多输出格式,并且一次能处理许多文本文件. 20.3 patchpatch程序将更改应用到文本文件中.它接受从difff程序的输出,并且通常被用来把较老的文件版本转变为较新的文件版本.使用diff/patch组合提供了两个重大优点: diff文件相较于整个源码树来说非常小. diff文件简洁地显示了所作的修改,从而允许程序补丁的审阅者能快速地评估它. diff -Naur old_file new_file &gt; diff_file 20.4 运行时编辑20.4.1 trtr程序被用来更改字符.可以看作是一种基于字符的查找和替换操作. 20.4.2 sedsed 是 stream editor (流编辑器)的简称.它对文本流进行编辑. 20.4.3 aspellaspell是一款交互式的拼写检查器. 1.21 格式化输出 nl 添加行号 fold 限制文件列宽 fmt 一个简单的文本格式转换器 pr 让文本为打印做好准备 printf 格式化数据并打印出来 groff 一个文件格式系统 21.1 简单的格式化工具21.1.1 nl 添加行号nl程序被用作一个简单的任务.它添加文件的行数.在它最简单的用途中,它相当于cat -n 21.1.2 fold 限制文件行宽折叠是将文本的行限制到特定的宽的过程.fold接受一个或多个文件及标准输入. 21.1.3 fmt 一个简单的文本格式器fmt程序同样折叠文本,外加很多功能.它接受文本或标准输入并且在文本流上呈现照片转换. 1.22 在linux下打印linux系统采用两套软件配合显示和管理打印. CUPS(Common Unix Printing System,一般Unix打印系统),用于提供打印驱动和打印任务管理; ,Ghostscript,一种PostScript解析器,作为RIP使用. pr 转换需要打印的文本文件 lpr 打印文件 lp 打印文件(System V) a2ps 为PostScript打印机格式化文件 lpstat 显示打印机状态信息 lpq 显示打印机队列状态 lprm 取消打印任务 cancel 取消打印任务(System V) 1.23 编译程序 可用性. 及时性. make 维护程序的工具 23.1 什么是编译编译就是把源码(一个由程序员编写的人类可读的程序描述)翻译成计算机处理器的母语的过程.用汇编语言编写的程序通过汇编器处理为机器语言.高级编程语言让程序员更专注于解决手头的问题.用高级语言编写的程序,经过另一个称为编译器的程序处理,会转换成机器语言.一些编译器把高级指令翻译成汇编语言,然后使用一个汇编器翻译成机器语言的最后阶段. 23.1.1 所有程序都是可编译的吗不是的.像shell,Python,PHP,Ruby和许多其它语言是用脚本或解释型语言编写的.脚本语言由一个叫做解释器的特殊程序执行.一个解释器输入程序文件,读取并执行程序中包含的每条指令.通常解释型程序执行起来要比编译程序慢很多.这是一位内每次解释型程序执行时,程序中每条源码指令都需要翻译,而一个编译程序,一条源码指令只翻译一次,翻译后的指令会永久地记录到最终的执行文件中.解释型语言的优势是开发解释型程序要比编译程序快速且容易. 23.2 编译一个C语言通过gcc和make编译. mkdir src cd src ftp ftp.gnu.org anonymous cd gnu/diction ls get diction-1.11.tar.gz bye注意:因为我们是这个源码的”维护者”,当我们编译它的时候,我们把它保存在~/src目录下.由你的系统发行版源码会把源码安装在/usr/src目录下,而供多个用户使用的源码,通常安装在/usr/local/src目录下.解压tar tar xzf diction-1.11.tar.gz当源码tar文件打开的时候,会创建一个目录,该目录包含了源码树,并且这个目录将会命名为project-x.xx,其包含了项目名称和它的版本号两项内容.这种方案能在系统中方便安装同一个程序的多个版本. 在解压前检查tar文件的内容: tar tzvf tarfile | head ---23.3 检查源码树属于GNU项目的程序,还有其它许多程序都会提供文档文件README,INSTALL,NEWS和COPYING.这些文件包含了程序描述,如果建立和安装它的信息,还有它的许可条款. 23.3.1 构建程序大多数程序通过简单的两个命令的序列构建: ./configure makeconfigure程序是一个shell脚本,由源码树提供.它的工作室分析程序建立环境.Makefile是一个配置文件,指示make程序究竟如何构建程序.没有它,make程序不能运行.make程序把makefile文件作为输入,makefile文件描述了包括最终完成的程序的个组件之间的关系和依赖性. 23.3.2 安装程序打包良好的源码经常包括一个特别的make目录文件,叫做install.这个目标文件将在系统目录中安装最终的产品,以供使用.通常,这个目录是/usr/local/bin,这是本地所构建软件的传统安装位置. sudo make install1.24 编写第一个Shell脚本24.1 什么是shell脚本一个shell脚本就是一个包含一系列命令的文件.shell不仅是一个功能强大的命令行接口,也是一个脚本语言解释器. 24.2 怎样编写一个shell脚本为了成功创建和运行一个shell脚本,我们需要做三件事: 编写一个脚本. 使脚本文件可执行. 把脚本放置到shell能够找到的地方. 24.3 脚本文件格式#!/bin/bash # This is our first script. echo &apos;Hello World!&apos;#!字符序列是一种特殊的结构叫做shebang.它被用来告诉操作系统将执行此脚本所用的解释器的名字.在文本行中,#副后之后的所有字符都会被忽略. 24.4 可执行权限对于脚本文件,有两个常见的权限设置: 权限为755的脚本,则每个人都能执行. 权限为700的脚本,只有文件所有者能够执行. 24.5 脚本文件位置为了能够运行此脚本,我们必须指定脚本文件明确的路径. echo $PATH查看PATH目录 export PATH=~/bin:&quot;$PATH&quot;通过在.bashrc文件中添加下面这一行,使其在新的终端会话中生效.为了把这个修改应用到当前的终端会话中,通过”sourcing”.bashrc文件来完成. ..bashrc这个点”.”命令是source命令的同义词,一个shell内部命令,用来读取一个制定的shel命令文件,并把它看作是从键盘中输入的一样. 注意:在Ubuntu系统中,如果存在/bin目录,当执行用户的.bashrc文件时,Ubuntu会自动地添加这个/bin目录到PATH变量中.所以在Ubuntu系统中,如果我们创建了这个~/bin目录,随后退出,然后再登陆,一切会正常运行. ~/bin 目录用来存放个人使用的脚本. /usr/local/bin 目录用来存放本地用户的脚本. /usr/local/sbin 目录用来存放系统管理使用的脚本. /bin | /usr/bin 目录用来存放Linux发行商提供和维护的文件(不要将个人或本地脚本存放于此).24.6 更多的格式技巧一个脚本可以轻松地被作者或其它用户修改,使它适应变化的需求.让脚本容易阅读和理解是一种方便维护的方法. 24.6.1 长选项名称长选项命令 ls --all --directory短选项命令 ls -ad这两个命令是等价的. 为了减少输入,当在命令行中输入选项的时候,短选项更受欢迎. 当书写脚本的时候,长选项能提供可读性. 24.6.2 缩进和行继续符当使用长命令的时候,通过把命令在几个文本行中展开,可以提高命令的可读性. find playground \\ \\(\\ -type f \\ -not -perm 066 \\ -exec chmod 066 &apos;{}&apos; &apos;;&apos; \\ \\)\\ -or \\ \\(\\ -type d \\ -not -perm 0711 \\ -exec chmod 0711 &apos;{}&apos; &apos;;&apos;\\ \\)通过使用行继续符(反斜杠-回车符序列)和缩进,使复杂命令的逻辑性更清楚地描述给读者.这个技巧在命令行中同样生效.脚本和命令行的一个区别是,脚本可能雇佣tab字符拉来实现缩进,然而命令行却不能,因为tab字符被用来激活自动补全功能. 1.25 启动一个项目25.1 第一阶段:最小的文档vim sys_info_page #!/bin/bash # Program to output a system information page echo &quot;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Page Title&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; Page body. &lt;/BODY&gt; &lt;/HTML&gt;&quot; chmod 755 ~/bin/sys_info_page sys_info_page &gt; sys_info_page.html firefox sys_info_page.html一个带引号的字符串可能包含换行符,因此可以包含多个文本行.Shell会持续读取文本直到遇到右引号.它在命令行中也是这样工作的. 25.2 第二阶段:添加一点儿数据#!/bin/bash # Program to output a system information page echo &quot;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;System Information Report&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;System Information Report&lt;/H1&gt; &lt;/BODY&gt; &lt;/HTML&gt;&quot;25.3 变量和常量#!/bin/bash # Program to output a system information page title=&quot;System Information Report&quot; echo &quot;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$title&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$title&lt;/H1&gt; &lt;/BODY&gt; &lt;/HTML&gt;&quot;通过创建一个名为title的变量,并把”System Information Report”字符串赋值给它,就可以利用参数展开功能,把这个字符串放到文件中的多个位置.注意:如果输入失误创建了一个控变量展开值为空,这对于需要参数的命令来说,会引起混乱. foo=foo.txt foo1=foo1.txt cp $foo $foo1 cp: missing destination file operand after &apos;foo.txt&apos;当shell碰到一个变量的时候,它会自动地创建它.关于这个问题,shell要求非常宽松,这可能会导致一些问题. foo=&quot;yes&quot; echo $foo yes echo $fool $首先我们把”yes”赋给变量foo,然后用echo命令来显示变量值.接着,我们显示拼写错误的变量名”fool”的变量值,然后得到一个空值.这是因为shell很高兴地创建了变量fool,当shell遇到fool的时候,并且赋给fool一个空的默认值.因此,我们必须小心谨慎地拼写. 变量名的规则: 变量名可由字母数字字符(字母和数字)和下划线字符组成. 变量名的第一个字符必须是一个字母或一个下划线. 变量名中不允许出现空格和标点符号. shell不能辨别常量和变量;它们大多数情况下是为了方便程序员.一个常用惯例是指定大写字母来表示常量,小写字母表示真正的变量. #!/bin/bash #Program to output a system information page TITLE=&quot;System InformationReport For $HOSTNAME&quot; echo &quot;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$title&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$title&lt;/H1&gt; &lt;/BODY&gt; &lt;/HTML&gt;通过在标题中添加shell变量名HOSTNAME,让标题变得活泼有趣些.这个变量名是这台机器的网络名称. 25.3.1 给变量和常量赋值variable=value这里的variable是变量的名字,value是一个字符串.不同于一些其它的编程语言,shell不会在乎变量值的类型;它把它们都看作是字符串. 注意:在赋值过程中,变量名,等号和变量值之间必须没有空格. 在参数展开过程中,变量名可以被花括号”{}”包围.在变量名周围的上下文变得不明确的情况下,这会很有帮助. filename=&quot;myfile&quot; touch $filename mv $filename $filename1 mv:missing destination file operand after &apos;myfile&apos;因为shell把mv命令的第二个参数解释为一个新的空的变量. mv $filename ${filename}1通过添加花括号,shell不再把末尾的1解释为变量名的一部分. #!/bin/bash # Program to output a system information page TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; echo &quot;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; &lt;/BODY&gt; &lt;/HTML&gt;&quot;25.4 Here Documents第三种文本输出方法叫做here document 或者 here script.一个 here document 是另外一种I/O重定向形式.我们在脚本文件中嵌入正文文本,然后把它发送给一个命令的标准输入. command &lt;&lt; token text token这里的command是一个可以接受标准输入的命令名,token是一个用来指示嵌入文本结束的字符串. #!/bin/bash # Program to output a system information page TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; cat &lt;&lt; _EOF_ &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; &lt;/BODY&gt; &lt;/HTML&gt; _EOF_取代echo命令,现在我们的脚本使用cat命令和一个here document.这个字符串EOF(意思是”文件结尾”,一个常见用法)被选作为token,并标志着嵌入文本的结尾.注意这个token必须在一行中单独出现,并且文本行中没有末尾的空格. 在here document中,shell不会注意引号.引号被看作是普通的字符.这就允许我们在一个here document中可以随意的嵌入引号. Here documents可以和任意能接受标准输入的命令一块使用. #!/bin/bash # Script to retrieve a file via FTP FTP_SERVER=ftp.nl.debian.org FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom REMOTE_FILE=debian-cd_info.tar.gz ftp -n &lt;&lt; _EOF_ open $FTP_SERVER user anonymous me@linuxbox cd $FTP_PATH hash get $REMOTE_FILE bye _EOF_ ls -l $REMOTE_FILE如果我们把重定向操作符从”&lt;&lt;”改为”&lt;&lt;-“,shell会忽略在此here document中开头的tab字符.这就能缩进一个here document,从而提高脚本的可读性. #!/bin/bash # Script to retrieve a file via FTP FTP_SERVER=ftp.nl.debian.org FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom REMOTE_FILE=debian-cd_info.tar.gz ftp -n &lt;&lt;- _EOF_ open $FTP_SERVER user anonymous me@linuxbox cd $FTP_PATH hash get $REMOTE_FILE bye _EOF_ ls -l $REMOTE_FILE1.26 自顶向下设计先确定上层步骤,然后再逐步西华这些步骤的过程被称为自顶向下设计.这种技巧允许我们把庞大而复杂的任务分割为许多小而简单的任务.自顶向下设计是一种常见的程序设计方法,尤其适合shell编程. 26.1 shell函数目前我们的脚本执行以下步骤来产生HTML文档: 打开网页 打开网页标头 设置网页标题 关闭网页标头 打开网页主体部分 输出网页标头 输出时间戳 关闭网页主体 关闭网页 为了下一阶段的开发,我们将在步骤7和8之间添加一些额外的任务.这些包括: 系统正常运行时间和负载.这是自上次关机或重启之后系统的运行时间,以及在几个时间间隔内当前运行在处理中的平均任务量. 磁盘空间.系统中存储设备的总使用量. 家目录空间.每个用户所使用的存储空间数量. 如果对于每个任务,我们都有相应的命令,那么通过命令替换,我们就能很容易地把它们添加到我们的脚本中. #!/bin/bash # Program to output a system information page TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; cat &lt;&lt; _EOF_ &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; $(report_uptime) $(report_disk_space) $(report_home_space) &lt;/BODY&gt; &lt;/HTML&gt; _EOF_我们可以使用两种方法创建这些额外的命令. 可以分别编写三个脚本,并把它们放置到环境变量PATH所列出的目录下; 可以把这些脚本作为shell函数嵌入到程序中.shell函数是位于其它脚本中的”微脚本”,作为自主程序.shell函数由两种语法形式: function name { commands return } name () { commands return }这里的name是函数名,commands是一系列包含在函数中的命令.两种形式是等价的,可以交替使用.注意:为了使函数调用被识别出是shell函数,而不是被解释为外部程序的名字,所以在脚本中shell函数定义必须出现在函数调用之前. #!/bin/bash#Program to output a system information pageTITLE=”System Information Report For $HOSTNAME”CURRENT_TIME=$(date +”%x %r %Z”)TIME_STAMP=”Generated $CURRENT_TIME, by $USER”report_uptime () {return}report_disk_space () {return}report_home_space () {return}cat &lt;&lt; EOF &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; $(report_uptime) $(report_disk_space) $(report_home_space) &lt;/BODY&gt; _EOF_ shell函数的命名规则和变量一样.一个函数必须至少包含一条命令.return命令(是可选的)满足要求. 26.2 局部变量局部变量只能在定义它们的shell函数中使用,并且一旦shell函数执行完毕,它们就不存在了.拥有局部变量允许程序员使用的局部变量名,可以与已存在的变量名相同,这些变量可以是全局变量,或者是其它shell函数中的局部变量,不用担心名字冲突. #!/bin/bash # local-vars: script to demonstrate local variables foo=0 # global variable foo funct_1 () { local foo # variable foo local to funct_1 foo=1 echo &quot;funct_1: foo = $foo&quot; } funct_2 () { local foo # variable foo local to funct_2 foo=2 echo &quot;funct_2: foo = $foo&quot; } echo &quot;global: foo = $foo&quot; funct_1 echo &quot;global: foo = $foo&quot; funct_2通过在变量名之前加上单词local,来定义局部变量.这就创建了一个只对其所在的shell函数起作用的变量.在这个shell函数之外,这个变量不再存在.这个功能允许shell函数能保持各自以及与它们所在脚本之间的独立性. 26.3 保持脚本运行#!/bin/bashProgram to output a system information pageTITLE=”System Information Report For $HOSTNAME”CURRENT_TIME=$(date +”%x %r %Z”)TIME_STAMP=”Generated $CURRENT_TIME, by $USER”report_uptime () { cat &lt;&lt;- EOF System Uptime $(uptime) EOF}report_disk_space () { cat &lt;&lt;- EOF Disk Space Utilization $(df -h) EOF}report_home_space () { cat &lt;&lt;- EOF Home Space Utilization $(du -sh /home/*) EOF}cat &lt;&lt; EOF$TITLE$TITLE$TIME_STAMP$(report_uptime)$(report_disk_space)$(report_home_space)EOF 1.27 流程控制:if分支结构怎样使我们的报告生成器脚本能适应运行此脚本的用户的权限,在脚本中基于测试条件结果,来&quot;改变方向&quot;.1,27,1 if逻辑如下: x=5 if [ $x = 5]; then echo “x equals 5.” else echo “x does not equal 5.” fi if语句语法如下: if commands; then commands [elif commands; then commands...] [else commands] fi这里的commands是指一系列命令. 27.2 退出状态当命令执行完毕后,命令(包含我们编写的脚本和shell函数)会给系统发送一个值,叫做退出状态.这个值是一个0到255之间的整数,说明命令执行成功或是失败.按照惯例,一个零值说明成功,其它所有值说明失败.shell提供了一个参数(echo $?),我们可以用它来检查退出状态. 27.3 测试目前为止,经常与if一块使用的命令是test.这个test命令执行各种各样的检查与比较. test expression [ expression] 这里的expression是一个表达式,其执行结果是true或者是false.当表达式为真时,这个test命令返回一个零退出状态,当表达式为假时,test命令退出状态为1. 27.3.1 文件表达式表达式 如果为真 file1 -ef file2 file1和file2拥有相同的索引号(通过硬链接两个文件名指向相同的文件). file1 -nt file2 file1新与file2. file1 -ot file2 file1早于file2. -b file file存在并且是一个块(设备)文件. -c file file存在并且是一个字符(设备)文件. -d file file存在并且是一个目录. -e file file存在. -f file file存在并且是一个普通文件. -g file file存在并且设置了组ID. -G file file存在并且由有效组ID拥有. -k file file存在并且设置了它的&quot;sticky bit&quot;. -L file file存在并且是一个符号链接. -O file file存在并且由有效用户ID拥有. -p file file存在并且是一个命名管道. -r file file存在并且可读(有效用户有可读权限). -s file file存在且其长度大于零. -S file file存在且是一个网络socket. -t fd fd是一个定向到终端/从终端定向到文件描述符. 这可以被用来决定是否重定向了标准输入/输出错误. -u file file存在并且设置了setuid位. -w file file存在并且可写. -x file file存在并且可执行.27.3.2 字符串表达式表达式 如果为真 string string不为null. -n string 字符串string的长度大于零. -z string 字符串string的长度为零. string1 = string2 string1和string2相同.单或双等号都可以,不过双等号更受欢迎. string1 != string2 string1 和string2不相同. string1 &gt; string2 string1排列在string2之后. string1 &lt; string2 string1排列在string2之前.注意:这个&gt;和&lt;表达式操作符必须用引号引起来(或者使用反斜杠转义),当与test一块使用的时候.如果不这样,它们会被shell解释为重定向操作符,造成潜在地破坏结果.同时也要注意虽然bash文档生命排序遵从当前语系的排列规则,但并不这样.将来的bash版本,包括4.0,使用ASCII(POSIX)排序规则. #!/bin/bash # test-string: evaluate the value of a string ANSWER=maybe if [ -z &quot;$ANSWER&quot; ]; then echo &quot;There is no answer.&quot; &gt;&amp;2 exit 1 fi if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then echo &quot;The answer is YES.&quot; elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then echo &quot;The answer is NO.&quot; elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then echo &quot;The answer is MAYBE.&quot; else echo &quot;The answer is UNKNOWN.&quot; fi在这个脚本中,我们计算常量ANSWER.我们首先确定是否此字符串为空.如果为空,我们就终止脚本,并把退出状态设为零.注意这个应用于echo命令的重定向操作.其把错误信息”There is no answer.”重定向到标准错误,这是处理错误信息的”合理”方法.如果字符串不为空,我们就计算字符串的值,看看它是否等于”yes”,”no”或者”maybe”.为此使用elif,它是”else if”的简写.通过使用elif,我们能够构建更复杂的逻辑测试. 27.3.3 整型表达式表达式 如果为真 integer1 -eq integer2 integer1等于integer2. integer1 -ne integer2 integer1不等于integer2. integer1 -le integer2 integer1小于或等于integer2. integer1 -lt integer2 integer1小于integer2. integer1 -ge integer2 integer1大于或等于integer2. integer1 -gt integer2 integer1大于integer2.例: #!/bin/bash # test-integer: evaluate the value of an integer. INT=-5 if [ -z “$INT” ]; then echo “INT is empty.” &gt;&amp;2 exit 1 fi if [ $INT -eq 0 ]; then echo “INT is zero.” else if [ $INT -lt 0 ]; then echo “INT is negative.” else echo “INT is positive.” fi if [ $((INT % 2)) -eq 0 ]; then echo “INT is even.” else echo “INT is odd.” fi fi确定一个整数是偶数还是奇数。通过用模数 2 对数字执行求模操作,就是用数字来除以 2,并返回余数,从而知道数字是偶数还是奇数。 27.4 更现代的测试版本[[ expression]]这里,类似于 test,expression 是一个表达式,其计算结果为真或假。这个 [[ ]] 命令非常相似于 test 命令(它支持所有的表达式),但是增加了一个重要的新的字符串表达式: string1 =~ regex其返回值为真,如果 string1 匹配扩展的正则表达式 regex。这就为执行比如数据验证等任务提供了许多可能性。在我们前面的整数表达式示例中,如果常量 INT 包含除了整数之外的任何数据,脚本就会运行失败。这个脚本需要一种方法来证明此常量包含一个整数。使用 [[]] 和 =∼ 字符串表达式操作符. #!/bin/bash # test-integer2: evaluate the value of an integer. INT=-5 if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then if [ $INT -eq 0 ]; then echo &quot;INT is zero.&quot; else if [ $INT -lt 0 ]; then echo &quot;INT is negative.&quot; else echo &quot;INT is positive.&quot; fi if [ $((INT % 2)) -eq 0 ]; then echo &quot;INT is even.&quot; else echo &quot;INT is odd.&quot; fi fi else echo &quot;INT is not an integer.&quot; &gt;&amp;2 exit 1 fi通过应用正则表达式,我们能够限制 INT 的值只是字符串,其开始于一个可选的减号,随后是一个或多个数字。这个表达式也消除了空值的可能性。 [[ ]] 添加的另一个功能是 == 操作符支持类型匹配,正如路径名展开所做的那样。例如: FILE=foo.bar if [[ $FILE == foo.* ]]; then echo &quot;$FILE matches pattern &apos;foo.*&apos;&quot; fi这就使 [[ ]] 有助于计算文件和路径名。 27.5 (()) 为整数设计","link":"/2020/04/19/linux-command-line/"}],"tags":[],"categories":[]}