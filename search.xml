<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flask Web 框架</title>
    <url>/2020/04/17/Flask%20Web%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Flask-Web框架"><a href="#Flask-Web框架" class="headerlink" title="Flask Web框架"></a>Flask Web框架</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install Flask==1.1.1</code></p>
<p>在pycharm里直接新建项目,选择flask项目创建,设置虚拟环境等.</p>
<h2 id="解释器-interpreter"><a href="#解释器-interpreter" class="headerlink" title="解释器(interpreter)"></a>解释器(interpreter)</h2><ul>
<li>Flask – Flask库文件</li>
<li>Jinja2 –模板语言</li>
<li>MarkupSafe –返回安全标签(Flask依赖markupsafe返回安全标签)</li>
<li>Werkzeug –(德语’工具’得意思)相当于uWSGI(应用存取网关接口),底层仍为WSGI</li>
</ul>
<a id="more"></a>

<h2 id="启动Flask"><a href="#启动Flask" class="headerlink" title="启动Flask"></a>启动Flask</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask # 导入Flask类创建Flask应用对象</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__) # app &#x3D; application</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;) # 为Flask应用对象添加路由</span><br><span class="line">def hello_world(): # 与路由绑定得视图函数,名称保持唯一</span><br><span class="line">    return &#39;Hello World!&#39; # 相当于Django中得HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;: # 当前文件处于脚本状态时运行如下代码</span><br><span class="line">    app.run() # 启动Flask应用</span><br></pre></td></tr></table></figure>

<h2 id="Flask中的Response"><a href="#Flask中的Response" class="headerlink" title="Flask中的Response"></a>Flask中的Response</h2><ol>
<li><p>HttpResponse “hello world!”</p>
</li>
<li><p>render(‘html文件’)    render_template(‘html文件’)</p>
</li>
<li><p>redirect(‘/home’)    redirect(‘/home’) </p>
<p>#3xx开头根据指令做出响应</p>
<p>#4xx 错误 客户端</p>
<p>#5xx 错误 服务器</p>
<p>#302 HTTP status  ResponseHeaders中加入一个Localtion:<a href="http://url" target="_blank" rel="noopener">http://url</a></p>
</li>
<li><p>send_file(‘文件路径’)    返回文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;get_file&#39;)</span><br><span class="line">def get_file():</span><br><span class="line">    return send_file(&#39;1.jpg&#39;)</span><br></pre></td></tr></table></figure>

<p>#打开并返回文件内容.Content-Type:可以被客户端识别得文件类型.</p>
<p>#在ResponseHeaders中加入,不能识别得类型,下载处理.</p>
</li>
<li><p>jsonify(‘字符串或数据类型’)    返回JSON字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;get_json&#39;)</span><br><span class="line">def get_json():</span><br><span class="line">    d &#x3D; &#123;d</span><br><span class="line">        &#39;name&#39;:&#39;Alexander.DSB.Li&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(d)</span><br></pre></td></tr></table></figure>

<p>#Content-Type:appliaction/json 返回标准格式的JSON字符串</p>
<p>#直接返回dict时,本质上在执行jsonify()</p>
</li>
</ol>
<h2 id="Flask中的request"><a href="#Flask中的request" class="headerlink" title="Flask中的request"></a>Flask中的request</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;])</span><br><span class="line">def login():</span><br><span class="line">    return render_template(&#39;login.html&#39;)</span><br></pre></td></tr></table></figure>



<p><code>methods=[&#39;GET&#39;,&#39;POST&#39;]</code>在路由的装饰器中允许请求方式.</p>
<ol>
<li><p><code>request.form.to_dict()</code>获取FormData中得数据to_dict(),ImmutableMultiDict</p>
</li>
<li><p>request.methods 获取请求方式</p>
</li>
<li><p>request.args.get(‘id) 获取URL中得数据字符串.支持get(‘key’)和to_dict()</p>
</li>
<li><p>request.files.get(‘my_file’) 提取文件.获取一个FileStorage Flask文件特殊对象.</p>
<p>my_file.save(my_file.filename)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            username:</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"'username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"my_file"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>firefox无法安装扩展插件</title>
    <url>/2020/04/17/firefox/</url>
    <content><![CDATA[<h2 id="扩展插件被阻止安装。"><a href="#扩展插件被阻止安装。" class="headerlink" title="扩展插件被阻止安装。"></a>扩展插件被阻止安装。</h2><p>Firefox Developer Edition已阻止此网站安装未经验证的附加组件。</p>
<p>在地址栏中输入<code>about:config</code> 按x找到 xpinstall.signatures.required 设置为false.</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>firefox</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 换源</title>
    <url>/2020/04/17/npm%20%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<h2 id="国内源"><a href="#国内源" class="headerlink" title="国内源"></a>国内源</h2><ul>
<li>淘宝npm镜像<ul>
<li>搜索地址: <a href="http://npm.taobao.org" target="_blank" rel="noopener">http://npm.taobao.org</a></li>
<li>registry地址: <a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a></li>
</ul>
</li>
<li>cnpmjs镜像<ul>
<li>搜索地址: <a href="http://cnpmjs.org" target="_blank" rel="noopener">http://cnpmjs.org</a></li>
<li>registry地址: <a href="http://r.cnpmjs.org" target="_blank" rel="noopener">http://r.cnpmjs.org</a></li>
</ul>
</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>临时使用<ul>
<li>npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> install express</li>
</ul>
</li>
<li>永久使用<ul>
<li>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li>
</ul>
</li>
<li>使用cnpm<ul>
<li>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>the linux command line</title>
    <url>/2020/04/19/linux-command-line/</url>
    <content><![CDATA[<img src="/2020/04/19/linux-command-line/1.jpg" class="" title="linux-command-line">

<h2 id="1-什么是shell"><a href="#1-什么是shell" class="headerlink" title="1. 什么是shell"></a>1. 什么是shell</h2><p>shell是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。<br>bash是来自GNU项目的shell程序。<br>bash是“Bourne Again Shell”的首字母缩写。<br>bash是最初Unix上由Steve Bourne写成shell程序sh的增强版。</p>
<h3 id="1-1-shell技巧"><a href="#1-1-shell技巧" class="headerlink" title="1.1. shell技巧"></a>1.1. shell技巧</h3><p>移动光标：借助上箭头按键获得上次输入的命令.借助左右按键把光标定位到命令行的任意位置。<br>tab：tab按键具有文件/目录/命令的补全功能。</p>
<a id="more"></a>

<h3 id="1-2-shell命令"><a href="#1-2-shell命令" class="headerlink" title="1.2. shell命令"></a>1.2. shell命令</h3><ul>
<li>date     日期</li>
<li>cal      日历</li>
<li>df       查看磁盘剩余空间。</li>
<li>free     查看空闲内存。</li>
<li>exit     退出shell。</li>
<li>pwd      打印当前目录名。</li>
<li>ls       列出目录内容</li>
<li>.        指工作目录</li>
<li>..       指工作目录的父目录</li>
<li>cd       更改目录</li>
<li>cd -     更改目录到先前的目录</li>
<li>cd ~user_name    更改工作目录到用户家目录.<br>  注:linux对大小写敏感且没有文件扩展名的概念.文件名支持标点符号仅限使用”.”和”-“及”_”.</li>
<li>file    当调用file命令后，file命令会打印出文件内容的简单描述。</li>
<li>less    用来浏览文本文件的程序.</li>
</ul>
<h2 id="2-linux系统中的目录"><a href="#2-linux系统中的目录" class="headerlink" title="2. linux系统中的目录"></a>2. linux系统中的目录</h2><ul>
<li>/       根目录,万物之源.</li>
<li>/bin    包含系统启动和运行所必须的二进制程序.</li>
<li>/boot   包含Linux内核,最初的RMA磁盘映像和启动加载程序.<br>  /boot/grub/grub.conf or menu.lst,用来配置启动加载程序.<br>  /boot/vmlinuz,linux内核</li>
<li>/dev    包含设备节点的特殊目录.”一切皆是文件”,也适用于设备.内核维护着它的支持设备.</li>
<li>/etc    包含所有系统层面的配置文件.同时也包含一系列的shell脚本,在系统启动时,这些脚本会运行每个系统服务.这个目录中的任何文件都应该是可读文本文件.<br>  /etc/crontab,定义自动运行的任务.<br>  /etc/fstab,包含存储设备的列表及相关挂载点.<br>  /etc/passwd,包含用户账号列表.</li>
<li>/home   系统会在/home下,为每个用户分配一个工作目录.</li>
<li>/lib    包含核心系统程序所需的库文件.类似windows中的动态链接库.</li>
<li>/lost+found 每个使用linux文件系统的格式化分区或设备,都会有这个目录.当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录是空的，除非文件系统损坏。</li>
<li>/media    包含可移动介质的挂载点。</li>
<li>/mnt    早些的系统中，/mnt目录包含可以东介质的挂载点。</li>
<li>/opt    用来安装“可选”软件。用来存储可能安装在系统中的商业软件产品。</li>
<li>/proc   是一个由Linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。这些可读的文件告诉你内核是怎样监管你的计算机的。</li>
<li>/root   root账户的家目录。</li>
<li>/sbin   包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。</li>
<li>/tmp    用来存储由各种程序创建的临时文件的地方。</li>
<li>/usr    包含普通用户所需要的所有程序和文件。<br>  /usr/bin    包含系统安装的执行程序。<br>  /usr/lib    包含/usr/bin目录中的程序所用的共享库。<br>  /usr/local  非系统发行版自带程序的安装目录。通常由源码编译的程序会安装在/usr/local/bin目录下。<br>  /usr/sbin   包含许多系统管理程序。<br>  /usr/share  包含许多由/usr/bin目录中的程序使用的共享数据。其中包括默认的配置文件、图表、桌面北京、音频文件等等。<br>  /usr/share/doc  包含安装在系统中的软件包的文档。</li>
<li>/var    存放的是动态文件。各种数据库，假脱机文件，用户邮件等等。<br>  /var/log    包含日至文件、各种系统活动的记录。其中/var/log/messages很重要。</li>
</ul>
<h2 id="3-符号链接"><a href="#3-符号链接" class="headerlink" title="3. 符号链接"></a>3. 符号链接</h2><p>创建硬链接   ln  当创建文件硬链接，实际是为文件创建了额外的名字部分，并且名字关联到相同的数据部分。硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。<br>创建符号链接   ln -s  创建符号链接既可以使用绝对路径也可以使用相对路径名。符号链接可以关联目录。</p>
<h2 id="4-命令的使用"><a href="#4-命令的使用" class="headerlink" title="4. 命令的使用"></a>4. 命令的使用</h2><pre><code>命令的四种形式：
    1.可执行程序.
    2.内建于shell自身的命令.
    3.shell函数.
    4.命令别名.自定义自己的命令,尖子在其他命令之上.</code></pre><h3 id="4-1-命令的识别"><a href="#4-1-命令的识别" class="headerlink" title="4.1. 命令的识别"></a>4.1. 命令的识别</h3><p>type    type command    shell的内部命令,它会显示命令的类别.<br>which   确定所执行程序的准确位置.只对可执行程序有效,不包括内建命令和命令别名.</p>
<h3 id="4-2-命令的文档"><a href="#4-2-命令的文档" class="headerlink" title="4.2. 命令的文档"></a>4.2. 命令的文档</h3><h4 id="4-2-1-help"><a href="#4-2-1-help" class="headerlink" title="4.2.1. help"></a>4.2.1. help</h4><p>得到shell内建命令的帮助文档.bash有一个内建的帮助工具.<br>–help  很多执行程序支持一个–help选项,这个想象是显示命令所支持的语法和选项说明.</p>
<h4 id="4-2-2-man"><a href="#4-2-2-man" class="headerlink" title="4.2.2. man"></a>4.2.2. man</h4><p>man program(program是要浏览的命令名)     显示程序手册页.许多可执行程序提供了一个正式的文档,叫做手册页(man page).</p>
<h4 id="4-2-3-apropos"><a href="#4-2-3-apropos" class="headerlink" title="4.2.3. apropos"></a>4.2.3. apropos</h4><p>显示适当的命令.<br>注意:man命令加上”-k”选项与apropos完成一样的功能.</p>
<h4 id="4-2-4-whatis-显示非常简介的命令说明"><a href="#4-2-4-whatis-显示非常简介的命令说明" class="headerlink" title="4.2.4. whatis  显示非常简介的命令说明"></a>4.2.4. whatis  显示非常简介的命令说明</h4><h4 id="4-2-5-info"><a href="#4-2-5-info" class="headerlink" title="4.2.5. info"></a>4.2.5. info</h4><p>显示程序Info条目.GNU项目提供了一个命令程序手册页的替代五,称其为”info”.</p>
<h4 id="4-2-6-README和其它程序文档"><a href="#4-2-6-README和其它程序文档" class="headerlink" title="4.2.6. README和其它程序文档"></a>4.2.6. README和其它程序文档</h4><p>   位于/usr/share/doc目录下的文本文件,可用less阅读器来浏览.以”.gz”结尾的文件是用gzip压缩程序压缩的.gzip软件包包含了一个特殊的less版本,叫做zless,可以显示由gzip压缩的文本文件内容.</p>
<h4 id="4-2-7-创建自己的命令"><a href="#4-2-7-创建自己的命令" class="headerlink" title="4.2.7. 创建自己的命令"></a>4.2.7. 创建自己的命令</h4><p>command1;command2;command3…<br>    例: cd /usr; ls; cd -<br>首先使用type 检测”command name”是否被使用.通过   alias foo=’cd /usr;ls/cd -‘来创建命令.<br>使用  unalias foo 命令来删除创建的foo命令.</p>
<h2 id="5-重定向"><a href="#5-重定向" class="headerlink" title="5. 重定向"></a>5. 重定向</h2><p>I/O重定向.”I/O”代表输入/输出,通过此工具可以重定向命令的输入输出,命令输入输出均来自文件.也可以把多个命令联结起来组成强大的命令管道.</p>
<h3 id="5-1-shell命令"><a href="#5-1-shell命令" class="headerlink" title="5.1. shell命令"></a>5.1. shell命令</h3><ul>
<li>cat     连接文件.<pre><code>例:cat movie.mpeg.0* &gt; movie.mpeg    因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。</code></pre></li>
<li>sort    排序文本行</li>
<li>uniq    报道或省略重复行</li>
<li>grep    打印匹配行</li>
<li>wc      打印文件中换行符,字和字节个数.</li>
<li>head    输出文件第一部分</li>
<li>tail    输出文件最后一部分</li>
<li>tee     从标准输入读取数据并写道标准输出和文件.</li>
</ul>
<p>许多程序都会产生某种输出.经常由两种类型组成.</p>
<ol>
<li><p>程序运行结果.</p>
</li>
<li><p>状态和错误信息.</p>
<p> I/O重定向允许我们梗概输出地点和输入来源.一般输入来自键盘,输出送到屏幕.通过I/O重定向,我们可以改变.<br> shell将文件流的前三个称作标准输入,标准输出和错误,称为表述副0,1,2.</p>
</li>
</ol>
<h3 id="5-2-标准输出重定向"><a href="#5-2-标准输出重定向" class="headerlink" title="5.2. 标准输出重定向"></a>5.2. 标准输出重定向</h3><ul>
<li><blockquote>
<blockquote>
<p>filename  将标准输出重定向到除屏幕意外的另一个文件.例:ls -l /bin/usr &gt;ls-output.txt</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>text.txt  没有命令在它之前,这回清空同名的文件内容或创建空文件.</p>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<p>filename 将重定向结果追加到文件内容或后面.</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="5-3-标准错误重定向"><a href="#5-3-标准错误重定向" class="headerlink" title="5.3. 标准错误重定向"></a>5.3. 标准错误重定向</h3><p>例:ls -l /bin/usr 2&gt;ls-error.txt 文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。</p>
<h4 id="5-3-1-重定向标准输出和错误到同一文件"><a href="#5-3-1-重定向标准输出和错误到同一文件" class="headerlink" title="5.3.1. 重定向标准输出和错误到同一文件"></a>5.3.1. 重定向标准输出和错误到同一文件</h4><ul>
<li>方法一:<br>  例:ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1   首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2&gt;&amp;1。重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。</li>
<li>方法二:<br>  例:ls -l /bin/usr &amp;&gt; ls-output.txt   用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt。</li>
</ul>
<h4 id="5-3-2-处理不需要的输出"><a href="#5-3-2-处理不需要的输出" class="headerlink" title="5.3.2. 处理不需要的输出"></a>5.3.2. 处理不需要的输出</h4><p>系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。<br>    例:ls -l /bin/usr 2&gt; /dev/null</p>
<h3 id="5-4-标准输入重定向"><a href="#5-4-标准输入重定向" class="headerlink" title="5.4. 标准输入重定向"></a>5.4. 标准输入重定向</h3><ul>
<li><p>例:cat &gt; lazy_dog.txt<br>  The quick brown fox jumped over the lazy dog.</p>
<p>  输入命令，其后输入要放入文件中的文本。输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）.通过使用这个命令，我们 实现了世界上最低能的文字处理器！</p>
</li>
<li><p>例:cat &lt; lazy_dog.txt<br>  使用”&lt;”重定向操作符,把标准输入源从键盘改到文件lazy_dog.txt.</p>
</li>
</ul>
<h4 id="5-4-1-管道线"><a href="#5-4-1-管道线" class="headerlink" title="5.4.1. 管道线"></a>5.4.1. 管道线</h4><ul>
<li>|    command1 | command2    使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入.<br>  例:ls -l /usr/bin | less</li>
</ul>
<h4 id="5-4-2-过滤器"><a href="#5-4-2-过滤器" class="headerlink" title="5.4.2. 过滤器"></a>5.4.2. 过滤器</h4><p>管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。</p>
<p>例:ls /bin /usr/bin | sort | less</p>
<p>因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个有序列表。</p>
<h4 id="5-4-3-uniq"><a href="#5-4-3-uniq" class="headerlink" title="5.4.3. uniq"></a>5.4.3. uniq</h4><p>报道或忽略重复行</p>
<p>默认情况下，从数据列表中删除任何重复行。uniq 命令经常和 sort 命令结合在一起使用。</p>
<p>例:ls /bin /usr/bin | sort | uniq | less</p>
<p>使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项.</p>
<h3 id="5-5-wc"><a href="#5-5-wc" class="headerlink" title="5.5. wc"></a>5.5. wc</h3><p>打印行数,字数和字节数</p>
<p>wc命令是用来显示文件所包含的行数,字数和字节数.它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。</p>
<h3 id="5-6-grep"><a href="#5-6-grep" class="headerlink" title="5.6. grep"></a>5.6. grep</h3><p>grep pattern [file…]  打印匹配行</p>
<p>用来找到文件中的匹配文本。grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</p>
<h3 id="5-7-head-tail"><a href="#5-7-head-tail" class="headerlink" title="5.7. head / tail"></a>5.7. head / tail</h3><p>打印文件开头部分/结尾部分.<br>head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。</p>
<p>tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。</p>
<h3 id="5-8-tee"><a href="#5-8-tee" class="headerlink" title="5.8. tee"></a>5.8. tee</h3><p>从 Stdin 读取数据，并同时输出到 Stdout 和文件</p>
<p>tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。</p>
<pre><code>例:ls /usr/bin | tee ls.txt | grep zip</code></pre><p>在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt.</p>
<h2 id="6-从shell眼中看世界"><a href="#6-从shell眼中看世界" class="headerlink" title="6. 从shell眼中看世界"></a>6. 从shell眼中看世界</h2><h3 id="6-1-字符展开"><a href="#6-1-字符展开" class="headerlink" title="6.1. 字符展开"></a>6.1. 字符展开</h3><ul>
<li>echo    显示一行文本。传递到 echo 命令的任一个参数都会在（屏幕上）显示出来。</li>
<li>echo *  ”<em>“字符意味着匹配文件名中的任意字符，shell 在 echo 命 令被执行前把”</em>“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。</li>
</ul>
<h3 id="6-2-路径名展开"><a href="#6-2-路径名展开" class="headerlink" title="6.2. 路径名展开"></a>6.2. 路径名展开</h3><p>echo ls -d .[!.]?*</p>
<p>  这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：ls -A</p>
<h3 id="6-3-波浪线展开"><a href="#6-3-波浪线展开" class="headerlink" title="6.3. 波浪线展开"></a>6.3. 波浪线展开</h3><p>波浪线字符”~”有特殊的含义.当用在一个单词的开头时,它会展开成制定用户的家目录名,如果没有制定用户名,则展开成当前用户的家目录.</p>
<h3 id="6-4-算术表达式展开"><a href="#6-4-算术表达式展开" class="headerlink" title="6.4. 算术表达式展开"></a>6.4. 算术表达式展开</h3><p>$((expression))</p>
<p>（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。</p>
<p>算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。在算术表达式中空格并不重要，并且表达式可以嵌套。</p>
<h3 id="6-5-花括号展开"><a href="#6-5-花括号展开" class="headerlink" title="6.5. 花括号展开"></a>6.5. 花括号展开</h3><p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列的整数，或者单个的字符串。这种模式不能 嵌入空白字符。</p>
<pre><code>例:echo Number_{1..5}    echo {A..Z}
echo Front-{A,B,C}-Back
花括号展开可以嵌套：echo a{A{1,2},B{3,4}}b
用花括号展开创建一系列文件/目录

例:mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}</code></pre><h3 id="6-6-参数展开"><a href="#6-6-参数展开" class="headerlink" title="6.6. 参数展开"></a>6.6. 参数展开</h3><p>它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。</p>
<pre><code>例:  echo $USER
要查看有效的变量列表,使用   printenv | less</code></pre><h3 id="6-7-命令替换"><a href="#6-7-命令替换" class="headerlink" title="6.7. 命令替换"></a>6.7. 命令替换</h3><p>命令替换允许我们把一个命令的输出作为一个展开模式来使用.</p>
<pre><code>例:  echo $(ls)  ls -l $(which cp)   file $(ls -l /usr/bin/* |grep zip)</code></pre><p>在bash中,也可以使用另一种语法—使用倒引号替代美元符号和括号.     ls -l <code>which cp</code></p>
<h3 id="6-8-引用"><a href="#6-8-引用" class="headerlink" title="6.8. 引用"></a>6.8. 引用</h3><p>shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。</p>
<h4 id="6-8-1-双引号"><a href="#6-8-1-双引号" class="headerlink" title="6.8.1. 双引号"></a>6.8.1. 双引号</h4><p>如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割、路径名展开、 波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。</p>
<pre><code>例:  ls -l &quot;two words.txt&quot;
    echo &quot;this is a    test&quot;</code></pre><p>在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。<br>    echo “this is a   test”<br>    单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。</p>
<p>事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影响。echo $(cal)与echo “$(cal)”.在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中， 命令行只有一个参数，参数中包括嵌入的空格和换行符。</p>
<h4 id="6-8-2-单引号"><a href="#6-8-2-单引号" class="headerlink" title="6.8.2. 单引号"></a>6.8.2. 单引号</h4><p>如果需要禁止所有的展开，我们要使用单引号。</p>
<h4 id="6-8-3-转义字符"><a href="#6-8-3-转义字符" class="headerlink" title="6.8.3. 转义字符"></a>6.8.3. 转义字符</h4><p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符.</p>
<p>使用转义字符来消除文件名中一个字符的特殊含义<br>    .mv bad$filename good_filename.</p>
<p>反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种 特殊字符，这些特殊字符叫做控制码。ASCII 编码表中前32个字符被用来把命令转输到电报机 之类的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），而其它 一些编码就不熟悉了（空值，传输结束码，和确认）。</p>
<ul>
<li>\a    响铃（”警告”－导致计算机嘟嘟响）</li>
<li>\b    退格符</li>
<li>\n    新的一行。在类 Unix 系统中，产生换行。</li>
<li>\r    回车符</li>
<li>\t    制表符</li>
</ul>
<p>这种利用反斜杠的表示法背后的思想来源于 C 编程语言， 许多其它语言也采用了这种表示方法，包括 shell。</p>
<h2 id="7-键盘高级操作技巧"><a href="#7-键盘高级操作技巧" class="headerlink" title="7. 键盘高级操作技巧"></a>7. 键盘高级操作技巧</h2><p>将要学习的命令：</p>
<ol>
<li>clear     清空屏幕</li>
<li>history   显示历史列表内容</li>
</ol>
<h3 id="7-1-命令行编辑"><a href="#7-1-命令行编辑" class="headerlink" title="7.1. 命令行编辑"></a>7.1. 命令行编辑</h3><p>Bash使用一个名为Readline的库（共享的例程几何，可以被不同的程序使用），用以实现命令行编辑。</p>
<h4 id="7-1-1-移动光标"><a href="#7-1-1-移动光标" class="headerlink" title="7.1.1. 移动光标"></a>7.1.1. 移动光标</h4><ul>
<li>Ctrl-a      移动光标到行首</li>
<li>Ctrl-e      移动光标到行尾</li>
<li>Ctrl-f      光标前移一个字符；和右箭头作用一样。</li>
<li>Ctrl-b      光标后移一个字符；和左箭头一样。</li>
<li>Alt-f       光标前移一个字。</li>
<li>Alt-f       光标前移一个字。</li>
<li>Alt-b       光标后移一个字。</li>
<li>Ctrl-l      清空屏幕，移动光标到左上角。clear命令完成同样的工作。</li>
</ul>
<h4 id="7-1-2-修改文本"><a href="#7-1-2-修改文本" class="headerlink" title="7.1.2. 修改文本"></a>7.1.2. 修改文本</h4><ul>
<li>Ctrl-d      删除光标位置的字符。</li>
<li>Ctrl-t      光标位置的字符和光标前面的字符互换位置。</li>
<li>Alt-t       光标位置的字和其前面的字互换位置。</li>
<li>Alt-l       把从光标位置到字尾的字符转换成小写字母。</li>
<li>Alt-u       把从光标位置到字尾的字符转换成大写字母。</li>
</ul>
<h4 id="7-1-3-剪切和粘贴文本"><a href="#7-1-3-剪切和粘贴文本" class="headerlink" title="7.1.3. 剪切和粘贴文本"></a>7.1.3. 剪切和粘贴文本</h4><p>Readline的文档使用术语killing和yanking来指我们平常所说的剪切和粘贴。剪切下来的本文被存储在一个叫做剪切环（kill-ring）的缓冲区中。</p>
<ul>
<li>Ctrl-k      剪切从光标位置到行为的文本。</li>
<li>Ctrl-u      将剪切从光标位置到行首的文本。</li>
<li>Alt-d       剪切从光标位置到词尾的文本。</li>
<li>Alt-Backspace   剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。</li>
<li>Ctrl-y      把剪切环中的文本粘贴到光标位置。</li>
</ul>
<h4 id="7-1-4-自动补全"><a href="#7-1-4-自动补全" class="headerlink" title="7.1.4. 自动补全"></a>7.1.4. 自动补全</h4><p>shell能帮助你的另一种方式是通过一种叫做自动补全的机制。</p>
<ul>
<li>Alt-？       显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按项次tab键，这会更容易些。</li>
<li>Alt-*       插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。</li>
</ul>
<h3 id="7-2-利用历史命令"><a href="#7-2-利用历史命令" class="headerlink" title="7.2. 利用历史命令"></a>7.2. 利用历史命令</h3><p>bash维护着一个已经执行过的命令的历史离别。这个命令列表被保存在你家目录下，一个名为.bash_history的文件里。</p>
<h3 id="7-3-搜索历史命令"><a href="#7-3-搜索历史命令" class="headerlink" title="7.3. 搜索历史命令"></a>7.3. 搜索历史命令</h3><p>history |grep /usr/bin    以及  !88</p>
<ul>
<li>递增搜索    Ctrl-r  启动递增搜索，其后输入要寻找的文本。</li>
<li>Ctrl-p      移动到上一个历史条目。类似于上箭头按键。</li>
<li>Ctrl-n      移动到下一个历史条目。类似于下箭头按键。</li>
<li>Alt-&lt;       移动到历史列表开头</li>
<li>Alt-&gt;       移动到历史列表结尾,即当前命令行.</li>
<li>Ctrl-r      反向递增搜索.从当前命令行开始,向上递增搜索.</li>
<li>Alt-p       反向搜索,非递增顺序.输入要查找的字符串,然后按下Enter,执行搜索.</li>
<li>Alt-n       向前搜索,非递增顺序.</li>
<li>Ctrl-o      执行历史列表中的当前项,并移到下一个.如果你想要执行历史列表中一系列的命令,这很方便.</li>
</ul>
<h3 id="7-4-历史命令展开"><a href="#7-4-历史命令展开" class="headerlink" title="7.4. 历史命令展开"></a>7.4. 历史命令展开</h3><ul>
<li>!number     重复历史列表中第number行的命令.</li>
<li>!!          重复最后一次执行的命令.可能按下上箭头按键和enter键更容易.</li>
<li>!string     重复最近历史列表中,以这个字符串开头的命令.</li>
<li>!?string    重复最近历史列表中,包含这个字符串的命令.</li>
</ul>
<h2 id="8-权限"><a href="#8-权限" class="headerlink" title="8. 权限"></a>8. 权限</h2><h3 id="8-1-拥有者-组成员和其他人"><a href="#8-1-拥有者-组成员和其他人" class="headerlink" title="8.1. 拥有者,组成员和其他人"></a>8.1. 拥有者,组成员和其他人</h3><p>id  用于查看当前用户的身份信息.用户账号自定义在/etc/passwd 文件中,用户组定义在/etc/group文件中.这些文件随着文件/etc/shadow的变动而修改.</p>
<h3 id="8-2-读取写入和执行"><a href="#8-2-读取写入和执行" class="headerlink" title="8.2. 读取写入和执行"></a>8.2. 读取写入和执行</h3><ul>
<li>-   一个普通文件</li>
<li>d    一个目录</li>
<li>l    一个符号链接.注意对于符号链接文件,生于的文件属性总是”rwxrwxrwx”,而且都是虚拟值.真正的文件属性是指符号链接所之乡的文件的属性.</li>
<li>c    一个字符设备文件.这种文件类型是指按照字节流来处理数据的设备.比如说终端机或者调制解调器.</li>
<li>b    一个块设备文件.这种文件类型是指按照数据块来处理数据的设备,例如一个硬盘或者CD-ROM盘.</li>
</ul>
<p>剩下的九个字符叫做文件模式,代表着文件所有者\文件组所有者和其他人的读\写和执行权限.</p>
<ul>
<li>r    文件:允许打开并读取文件内容.<br>  目录:允许列出目录中的内容,前提是目录必须设置了可执行属性.</li>
<li>w    文件:允许写入文件内容或截断文件.但是不允许对文件进行重命名或删除,重命名或删除是由目录的属性决定的.<br>  目录:允许在目录下新建\删除或重命名文件,前提是目录必须设置了可执行属性(x).</li>
<li>x    文件:允许将文件作为程序来执行,使用脚本语言编写的程序必须设置为可读才能被执行.<br>  目录:允许进入目录,例如:cd directory.</li>
</ul>
<h3 id="8-3-chmod更改文件模式"><a href="#8-3-chmod更改文件模式" class="headerlink" title="8.3. chmod更改文件模式"></a>8.3. chmod更改文件模式</h3><p>只有文件的所有者或者超级用户才能更改文件或目录的模式.chmod命令支持两种不同的方法来改变文件模式:八进制数字表示法或符号表示法.<br>    八进制表示法:</p>
<ul>
<li>0     000    —</li>
<li>1     001    –x</li>
<li>2     010    -w-</li>
<li>3     011    -wx</li>
<li>4     100    r–</li>
<li>5     101    r-x</li>
<li>6     110    rw-</li>
<li>7     111    rwx</li>
</ul>
<p>每个八进制数字代表了3个二进制数字,这种对应关系,正好映射到用来存储文件模式所使用的方案上.7(rwx),6(rw-),5(r-x),4(r–),0(—).八进制的7用二进制表示为111.</p>
<pre><code>符号表示法:</code></pre><ul>
<li>u    “user”的简写,意思是文件或目录的所有者.</li>
<li>g    “group”的简写.用户组</li>
<li>o    “others””的简写,意思是其他所有的人.</li>
<li>a    “all”的简写,是”u”,”g”和”o”的联合.</li>
</ul>
<p>chmod符号表示法实例:</p>
<ul>
<li>u+x    为文件所有者添加可执行权限.</li>
<li>u-x    删除文件所有者的可执行权限.</li>
<li>+x     为文件所有者,用户组和其他所有人添加可执行权限.等价于a+x.</li>
<li>o-rw   除了文件所有者和用户组,删除其他人的读权限和写权限.</li>
<li>go=rw  给群组的主任和人以文件拥有着的人读写权限.如果群组的主人或全局之前已经有了执行的权限,他们将被移除.</li>
<li>u+x,go=rw    给文件拥有着执行权限并给组和其他人读和执行的权限.多种设定可以用逗号分开.</li>
</ul>
<h3 id="8-4-umask设置默认权限"><a href="#8-4-umask设置默认权限" class="headerlink" title="8.4. umask设置默认权限"></a>8.4. umask设置默认权限</h3><p>当创建一个文件时,umask命令控制着文件的默认权限.umask命令使用八进制表示法来表达从文件模式属性中删除一个位掩码.一个八进制的权限掩码用三位数字来表示,但是umask用四位数字来表示.这是因为除了读取,写入和执行权限之外,还有其他较少用到的权限设置.</p>
<p>setuid(八进制4000),当应用到一个可执行文件时,它把有效的用户ID从真正的用户设置成程序所有者ID.当一个普通用户运行一个程序,这个程序由根用户所有,并且设置了setuid位,这个程序运行时具有超级用户的特权,这样程序就可以访问普通用户禁止访问的文件和目录.</p>
<p>setgid位(八进制2000),把有效用户组ID从真正的用户组ID梗概为文件所有者的组ID.如果设置了一个目录的setgid位,则目录中新创建的文件具有这个目录用户组的所有权,而不是文件创建者所属用户组的所有权.</p>
<p>sticky位(八进制1000),他可以把一个可执行文件标志为”不可交换的”.在linux中,会忽略文件的sticky位,但是如果一个目录设置了sticky位,那么它能组织用户删除或重命名文件,除非用户是这个目录的所有者或文件所有者,或超级用户.</p>
<ul>
<li>chmod u+s program    授予一个程序setuid权限</li>
<li>chmod g+s dir        授予一个目录setgid权限</li>
<li>chmod +t dir         授予一个目录sticky权限</li>
</ul>
<h3 id="8-5-更改身份"><a href="#8-5-更改身份" class="headerlink" title="8.5. 更改身份"></a>8.5. 更改身份</h3><pre><code>su    以其他用户身份和组ID运行一个shell
sudo    以另一个用户身份执行命令</code></pre><h3 id="8-6-chown更改文件所有者和用户组"><a href="#8-6-chown更改文件所有者和用户组" class="headerlink" title="8.6. chown更改文件所有者和用户组"></a>8.6. chown更改文件所有者和用户组</h3><p>chown [owner][:[group]] file…</p>
<h3 id="8-7-chgrp更改用户组所有权"><a href="#8-7-chgrp更改用户组所有权" class="headerlink" title="8.7. chgrp更改用户组所有权"></a>8.7. chgrp更改用户组所有权</h3><p>chgrp [group] file…</p>
<h3 id="8-8-更改用户密码"><a href="#8-8-更改用户密码" class="headerlink" title="8.8. 更改用户密码"></a>8.8. 更改用户密码</h3><p>passwd [user]</p>
<p>如果你具有超级用户权限,你可以指定一个用户名作为passwd命令的参数,这样可以设置另一个用户的密码.</p>
<h2 id="9-进程"><a href="#9-进程" class="headerlink" title="9. 进程"></a>9. 进程</h2><h3 id="9-1-进程是怎样工作的"><a href="#9-1-进程是怎样工作的" class="headerlink" title="9.1. 进程是怎样工作的"></a>9.1. 进程是怎样工作的</h3><p>当系统启动的时候,内和先把一些它自己的活动初始化位进程,然后运行一个叫做init的程序.init,依次第,再运行一系列的称为init脚本的shell脚本(位于/etc),它们可以启动所有的系统服务.其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户界面.</p>
<p>在进程方案中,一个程序可以发动另一个程序被表述位一个父进程可以产生一个子进程.</p>
<p>内核维护每个进程的信息,以此来保持事情有序.系统分配给每个进程一个数字,这个数字叫做进程ID或PID.PID号按升序分配,init进程的PID总是1.内和也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程.</p>
<h3 id="9-2-查看进程"><a href="#9-2-查看进程" class="headerlink" title="9.2. 查看进程"></a>9.2. 查看进程</h3><ul>
<li>ps    命令查看进程</li>
</ul>
<p>进程状态表</p>
<ul>
<li><p>R    运行中.</p>
</li>
<li><p>S    正在睡眠.进程没有运行,而是正在等待一个事件.</p>
</li>
<li><p>D    不可中断睡眠.进程正在等待I/O,例:一个磁盘驱动器的I/O</p>
</li>
<li><p>T    已停止.已经指示进程停止运行.</p>
</li>
<li><p>Z    一个死进程或”僵尸”进程.这是一个已经种植的紫禁城,但是它的父进程没有清空它.</p>
</li>
<li><p>&lt;    一个高优先级进程.这会授予一个进程更多重要的资源,给它更多的CPU时间.</p>
</li>
<li><p>N    低优先级进程.</p>
</li>
<li><p>ps x     展示所有进程</p>
</li>
<li><p>ps aux   这个选项组合,能够显示属于每个用户的进程信息.此命令唤醒”BSD风格”的输出结果.</p>
<p>  BSD风格ps命令列标题</p>
</li>
<li><p>USER    用户ID.进程的所有者.</p>
</li>
<li><p>%CPU    以百分比表示的CPU使用率</p>
</li>
<li><p>%MEM    以百分比表示的内存使用率</p>
</li>
<li><p>VSZ      虚拟内存大小</p>
</li>
<li><p>RSS      进程占用的物理内存的大小,以千字节位单位.</p>
</li>
<li><p>START    进程启动的时间.若它的值超过24小时,则用天表示.</p>
</li>
</ul>
<h3 id="9-3-用top命令动态查看进程"><a href="#9-3-用top命令动态查看进程" class="headerlink" title="9.3. 用top命令动态查看进程"></a>9.3. 用top命令动态查看进程</h3><p>“top”这个名字来源于top程序是用来查看系统中”顶端”进程的.top显示结果由两部分组成:最上面是系统概要,下面是进程列表,以CPU的使用率排序.</p>
<p>top命令信息字段</p>
<pre><code>行号    字段            意义
1     top            程序名
       14:59:20       当前时间.
       up 6:30        这是正常运行时间.
       2users         有两个用户登陆系统
       load average:  加载平均值,等待运行的进程数目.
2     Tasks:         总结进程数目和这些进程的状态.
3     Cpu(s):        这一行描述了CPU正在进行的活动特性.
       0.7%us         0.7%的CPU被用于用户进程.
       1.0%sy         1.0%的CPU时间被用于系统(内核)进程.
       0.0%ni         0.0%的CPU时间被用于&quot;nice&quot;(低优先级)进程.
       98.3%id        98.3%的CPU时间是空闲的.
       0.0%wa         0.0%的CPU时间来等待I/O.
4     Mem:           展示物理内存的使用情况.
5     Swap           展示交换分区(虚拟内存)的使用情况.</code></pre><h3 id="9-4-控制进程"><a href="#9-4-控制进程" class="headerlink" title="9.4. 控制进程"></a>9.4. 控制进程</h3><h3 id="9-5-中断一个进程"><a href="#9-5-中断一个进程" class="headerlink" title="9.5. 中断一个进程"></a>9.5. 中断一个进程</h3><h3 id="9-6-把一个进程放置到后台执行"><a href="#9-6-把一个进程放置到后台执行" class="headerlink" title="9.6. 把一个进程放置到后台执行"></a>9.6. 把一个进程放置到后台执行</h3><p>为了启动一个程序并让它立即在后台运行,我们在程序命令之后加上”&amp;”字符.</p>
<h3 id="9-7-进程返回到前台"><a href="#9-7-进程返回到前台" class="headerlink" title="9.7. 进程返回到前台"></a>9.7. 进程返回到前台</h3><p>用jobs查看运行的人物,fg命令之后,跟随一个百分号和任务序号(jobspec)就可以了.</p>
<h3 id="9-8-停止一个进程"><a href="#9-8-停止一个进程" class="headerlink" title="9.8. 停止一个进程"></a>9.8. 停止一个进程</h3><p>ctrl-z    可以停止一个进程,非终止它.</p>
<p>用bg命令把程序移到后台.</p>
<h3 id="9-9-Signals"><a href="#9-9-Signals" class="headerlink" title="9.9. Signals"></a>9.9. Signals</h3><p>kill命令用来终止程序.</p>
<ul>
<li>kill [-signal] PID… 没有指定信号,默认发送TERM(终止)信号.</li>
</ul>
<p>常用信号</p>
<ul>
<li><p>1.HUP    挂起     当一个守护进程受到这个信号,会重新启动并读取配置文件.</p>
</li>
<li><p>2.INT    中断     实现和Ctrl-c一样的功能,由中断发送.通常会终止一个程序.</p>
</li>
<li><p>3.QUIT   退出</p>
</li>
<li><p>9.KILL   杀死     KILL信号从不被发送到目标程序,而是内核立即终止这个进程.</p>
</li>
<li><p>11.SEGV  段错误   如果一个程序非法使用内存,就会发送这个信号.</p>
</li>
<li><p>15.TERM  终止     如果程序仍然”或者”,可以接受信号,那么这个会终止它.</p>
</li>
<li><p>18.CONT  继续     在一个停止信号后,这个信号会恢复进程的运行.</p>
</li>
<li><p>19.STOP  停止     这个信号导致进程停止运行,而不是终止.</p>
</li>
<li><p>20.TSTP  终端停止  当按下Ctrl-z组合键后,终端发送这个信号</p>
</li>
<li><p>28.WINCH 改变窗口大小  当改变窗口大小时,系统会发送这个信号.</p>
<p>  例:<br>  kill -9    13546<br>  kill -KILL 13546</p>
</li>
</ul>
<h3 id="9-10-通过killall命令给多个进程发送信号"><a href="#9-10-通过killall命令给多个进程发送信号" class="headerlink" title="9.10. 通过killall命令给多个进程发送信号"></a>9.10. 通过killall命令给多个进程发送信号</h3><p>killall [-u user] [-signal] name…</p>
<h3 id="9-11-更多和进程相关的命令"><a href="#9-11-更多和进程相关的命令" class="headerlink" title="9.11. 更多和进程相关的命令"></a>9.11. 更多和进程相关的命令</h3><ul>
<li>pstree  输出一个树型结构的进程列表.这个列表展示了进程见父/子关系.</li>
<li>vmstat  输出一个系统资源使用快照.包括内存,交换分区和磁盘I/O.</li>
<li>xload   一个图形界面程序,可以划出系统负载随时间变化的图形.</li>
<li>tload   与xload程序相似,但是在终端画出图形.</li>
</ul>
<h2 id="10-shell环境"><a href="#10-shell环境" class="headerlink" title="10. shell环境"></a>10. shell环境</h2><ul>
<li>printenv   打印部分或所有的环境变量.</li>
<li>set        设置shell选项</li>
<li>export     导出环境变量,让随后执行的程序知道.</li>
<li>alias      创建命令别名</li>
</ul>
<h3 id="10-1-什么存储在环境变量中"><a href="#10-1-什么存储在环境变量中" class="headerlink" title="10.1. 什么存储在环境变量中"></a>10.1. 什么存储在环境变量中</h3><ul>
<li>环境变量</li>
<li>shell变量</li>
</ul>
<h3 id="10-2-检查环境变量"><a href="#10-2-检查环境变量" class="headerlink" title="10.2. 检查环境变量"></a>10.2. 检查环境变量</h3><ul>
<li>set         显示shell和环境变量两者</li>
<li>printenv    只显示环境变量</li>
<li>alias       查看别名</li>
</ul>
<h3 id="10-3-一些有趣的变量"><a href="#10-3-一些有趣的变量" class="headerlink" title="10.3. 一些有趣的变量"></a>10.3. 一些有趣的变量</h3><ul>
<li>DISPLAY     通常为”0”,意思是由X产生的第一个显示器.</li>
<li>EDITOR      文本编辑器的名字.</li>
<li>SHELL       shell程序的名字.</li>
<li>HOME        用户家目录.</li>
<li>LANG        定义了字符集以及语言编码方式.</li>
<li>OLD_PWD     先前的工作目录.</li>
<li>PAGER       页输出程序的名字.者经常设置为/usr/bin/less.</li>
<li>PATH        由冒号分开的目录列表,当输入程序名后,会搜索这个目录列表.</li>
<li>PS1         Prompt String 1.这个定义了你的shell提示符的内容.</li>
<li>TERM        终端类型名.类Unix的系统支持许多终端协议;这个变量设置你的终端仿真器所用的协议.</li>
<li>TZ          制定你所在的时区.</li>
<li>USER        你的用户名.</li>
</ul>
<h3 id="10-4-如何建立shell环境"><a href="#10-4-如何建立shell环境" class="headerlink" title="10.4. 如何建立shell环境"></a>10.4. 如何建立shell环境</h3><p>shell会话类型:登陆shell会话;非登陆shell会话.</p>
<p>登陆shell会读取一个或多个启动文件.</p>
<pre><code>文件                 内容
/etc/profile        应用于所有用户的全局配置脚本.
~/.bash_profile     用户私人的启动文件.可用来扩展或重写全局配置脚本中的设置.
~/.bash_login       如果文件~/.bash_profile没有找到.bash会尝试读取这个脚本.
~/.profile          如果~/.bash_profile或文件~/.bash_login都没有找到.bash会试图读取这个文件.这是基于Debian发行版的默认设置.</code></pre><p>非登陆shell会话会读取以下启动文件:</p>
<pre><code>文件                 内容
/etc/bash.bashrc    应用于所有用户的全局配置文件.
~/.bashrc           用户私有的启动文件.可以用来扩展或重写全局配置脚本中的设置.</code></pre><h3 id="10-5-一个启动文件的内容"><a href="#10-5-一个启动文件的内容" class="headerlink" title="10.5. 一个启动文件的内容"></a>10.5. 一个启动文件的内容</h3><p>以”#”开头的行是注释,shell不会读取它们.</p>
<p>PATH变量经常在/etc/profile启动文件中设置.</p>
<h3 id="10-6-修改shell环境"><a href="#10-6-修改shell环境" class="headerlink" title="10.6. 修改shell环境"></a>10.6. 修改shell环境</h3><h3 id="10-7-我们应该修改哪个文件"><a href="#10-7-我们应该修改哪个文件" class="headerlink" title="10.7. 我们应该修改哪个文件"></a>10.7. 我们应该修改哪个文件</h3><h3 id="10-8-文本编辑器"><a href="#10-8-文本编辑器" class="headerlink" title="10.8. 文本编辑器"></a>10.8. 文本编辑器</h3><p>文本编辑器分为两种基本类型:图形化的和基于文本的编辑器.</p>
<h3 id="10-9-使用文本编辑器"><a href="#10-9-使用文本编辑器" class="headerlink" title="10.9. 使用文本编辑器"></a>10.9. 使用文本编辑器</h3><p>nano    less vi</p>
<h3 id="10-10-激活修改"><a href="#10-10-激活修改" class="headerlink" title="10.10. 激活修改"></a>10.10. 激活修改</h3><p>source .bashrc  强迫bash重新读取修改过的.bashrc文件</p>
<h2 id="11-vi简介"><a href="#11-vi简介" class="headerlink" title="11. vi简介"></a>11. vi简介</h2><h3 id="11-1-学习vi"><a href="#11-1-学习vi" class="headerlink" title="11.1. 学习vi"></a>11.1. 学习vi</h3><p>vi很多系统都预装.<br>vi是轻量级且执行快速的编辑器.</p>
<h3 id="11-2-vi背景介绍"><a href="#11-2-vi背景介绍" class="headerlink" title="11.2. vi背景介绍"></a>11.2. vi背景介绍</h3><h3 id="11-3-启动和停止vi"><a href="#11-3-启动和停止vi" class="headerlink" title="11.3. 启动和停止vi"></a>11.3. 启动和停止vi</h3><ul>
<li>vi  启动vi</li>
<li>:q  退出</li>
<li>:q! 强制退出</li>
</ul>
<h3 id="11-4-插入模式"><a href="#11-4-插入模式" class="headerlink" title="11.4. 插入模式"></a>11.4. 插入模式</h3><p>i按键进入插入模式</p>
<h3 id="11-5-保存"><a href="#11-5-保存" class="headerlink" title="11.5. 保存"></a>11.5. 保存</h3><p>:w  保存修改</p>
<h3 id="11-6-移动光标"><a href="#11-6-移动光标" class="headerlink" title="11.6. 移动光标"></a>11.6. 移动光标</h3><ul>
<li>l or 右箭头         向右移动一个字符</li>
<li>h or 左箭头         向左移动一个字符</li>
<li>j or 下箭头         向下移动一行</li>
<li>k or 上箭头         向上移动一行</li>
<li>0(按键)             移动到当前行的行首</li>
<li>^                  移动到当前行的第一个非空字符.</li>
<li>$                  移动到当前行的末尾.</li>
<li>w                   移动到下一个单词或标点符号的开头</li>
<li>W                   移动到下一个单词的开头,忽略标点符号.</li>
<li>b                   移动到上一个单词或标点符号的开头.</li>
<li>B                   移动到上一个单词的开头,忽略标点符号</li>
<li>Ctrl-f or Page Down 向下翻一页</li>
<li>Ctrl-b or Page Up   向上翻一页</li>
<li>numberG             移动到第number行.</li>
<li>G                   移动到文件末尾.</li>
</ul>
<h3 id="11-7-基本编辑"><a href="#11-7-基本编辑" class="headerlink" title="11.7. 基本编辑"></a>11.7. 基本编辑</h3><p>u按键       命令模式下会撤销卒后一次修改.</p>
<h4 id="11-7-1-追加文本"><a href="#11-7-1-追加文本" class="headerlink" title="11.7.1. 追加文本"></a>11.7.1. 追加文本</h4><p>a      命令模式下光标移动到行为.</p>
<h4 id="11-7-2-打开一行"><a href="#11-7-2-打开一行" class="headerlink" title="11.7.2. 打开一行"></a>11.7.2. 打开一行</h4><ul>
<li>o       当前行的下方打开一行.</li>
<li>O       当前行的上方打开一行.</li>
</ul>
<h4 id="11-7-3-删除文本"><a href="#11-7-3-删除文本" class="headerlink" title="11.7.3. 删除文本"></a>11.7.3. 删除文本</h4><ul>
<li>x       删除当前字符</li>
<li>3x      删除当前字符及气候的两个字符.</li>
<li>dd      删除当前行</li>
<li>5dd     删除当前行及随后的四行文本.</li>
<li>dW      删除从光标位置开始到下一个单词的开头.</li>
<li>d$      从光标位置开始到当前行的行尾.</li>
<li>d0      从光标位置开始到当前行的行首.</li>
<li>d^      从光标位置开始到文本行的第一个非空字符.</li>
<li>dG      从当前行到文件的末尾.</li>
<li>d20G    从当前行到文件的第20行.</li>
</ul>
<h4 id="11-7-4-剪切-复制和粘贴文本"><a href="#11-7-4-剪切-复制和粘贴文本" class="headerlink" title="11.7.4. 剪切,复制和粘贴文本"></a>11.7.4. 剪切,复制和粘贴文本</h4><ul>
<li>d       删除的文本被复制到一个粘贴缓冲区</li>
<li>p       将剪切板的文本粘贴到光标位置之后</li>
<li>P       将剪切板中的文本粘贴到光标之前.</li>
<li>yy      复制当前行.</li>
<li>5yy     复制当前行及随后的四行文本.</li>
<li>yW      复制从当前光标位置到下一个单词的开头.</li>
<li>y$      复制从当前光标位置到当前行的末尾.</li>
<li>y0      复制从当前光标位置到行首.</li>
<li>y^      复制从当前光标位置到文本行的第一个非空字符.</li>
<li>yG      复制从当前行到文件末尾.</li>
<li>y20G    复制从当前行到文件的第20行.</li>
</ul>
<h3 id="11-8-查找和替换"><a href="#11-8-查找和替换" class="headerlink" title="11.8. 查找和替换"></a>11.8. 查找和替换</h3><h4 id="11-8-1-查找一行"><a href="#11-8-1-查找一行" class="headerlink" title="11.8.1. 查找一行"></a>11.8.1. 查找一行</h4><p>f   查找一行,移动光标到下一个所制定的字符.</p>
<pre><code>例:fa   把光标定位到统一行中下一个出现的&quot;a&quot;字符.通过&quot;;&quot;来重复这个查找.</code></pre><h4 id="11-8-2-查找整个文件"><a href="#11-8-2-查找整个文件" class="headerlink" title="11.8.2. 查找整个文件"></a>11.8.2. 查找整个文件</h4><ul>
<li>/       移动光标到下一个出现的单词或短语上.通过n命令来重复先前的查找.</li>
<li>/Line   把光标移动到文件的第一行.</li>
</ul>
<h4 id="11-8-3-全局查找和替代"><a href="#11-8-3-全局查找和替代" class="headerlink" title="11.8.3. 全局查找和替代"></a>11.8.3. 全局查找和替代</h4><p>:%s/Line/line/gc 把整个文件中的单词”Line”更改为”line”</p>
<ul>
<li>:       冒号字符运行一个ex命令</li>
<li>%       指定要操作的行数.%是个快捷方式,表示从第一行到最后一行.<pre><code>1,5表示从第一行到第五行.
1,$表示从第一行到文件的最后一行.</code></pre></li>
<li>s       指定操作.这种情况是,替换(查找与替代).</li>
<li>/Line/line  查找类型与替代文本.</li>
<li>g       全局的意思.意味着对文本行中所有匹配的字符串执行查找和替换操作.如果省略g,则只替换每个文本行中第一个匹配的字符串.</li>
<li>c       指定一个需要用户确定的替换命令.</li>
<li>y       执行替换操作</li>
<li>n       跳过这个匹配的实例</li>
<li>a       对这个及随后所有匹配的字符串执行替换操作.</li>
<li>q or esc    退出替换操作.</li>
<li>l       执行这次替换并退出.l是”last”简写.</li>
<li>Ctrl-e,Ctrl-y   分别是向下滚动和向上滚动.用于查看建议替换的上下文.</li>
</ul>
<h3 id="11-9-编辑多个文件"><a href="#11-9-编辑多个文件" class="headerlink" title="11.9. 编辑多个文件"></a>11.9. 编辑多个文件</h3><p>vi file1 file2 file3…</p>
<ul>
<li>:n          从一个文件转到下一个文件.</li>
<li>:N          回到先前的文件.</li>
<li>:buffers    会在屏幕顶部显示一个文件列表.</li>
<li>:r file     把指定的文件插入到光标位置之前.</li>
</ul>
<p>注意:在通过:n或:N命令再由:e命令加载的文件之间切换.这时要使用:buffer命令,气候加上缓冲区号码,来转换文件.</p>
<h3 id="11-10-保存工作"><a href="#11-10-保存工作" class="headerlink" title="11.10. 保存工作"></a>11.10. 保存工作</h3><ul>
<li>ZZ          命令模式下输入ZZ就会保存并退出当前文件.</li>
<li>:w filename 把文件另存为(文件名)</li>
</ul>
<h2 id="12-自定制shell提示符"><a href="#12-自定制shell提示符" class="headerlink" title="12. 自定制shell提示符"></a>12. 自定制shell提示符</h2><h3 id="12-1-解剖一个提示符"><a href="#12-1-解剖一个提示符" class="headerlink" title="12.1. 解剖一个提示符"></a>12.1. 解剖一个提示符</h3><p>提示符包含我们的用户名,主机名和当前工作目录.它是由一个环境变量定义的,叫做PS1(prompt string one),可通过echo命令来查看PS1的内容.</p>
<pre><code>[me@linuxbox ~]$ echo $PS1
[\u@\h \W]\$</code></pre><ul>
<li>\a      以ASCII格式编码的铃声.当遇到这个转义序列时,计算机会发出嗡嗡的响声.</li>
<li>\d      以日,月,天格式来表示当前日期.</li>
<li>\h      本地机的主机名,但不代末尾的域名.</li>
<li>\H      完整的主机名.</li>
<li>\j      运行在当前shell会话中的工作数.</li>
<li>\l      当前终端设备名.</li>
<li>\n      一个换行符.</li>
<li>\r      一个回车符.</li>
<li>\s      shell程序名.</li>
<li>\t      以24小时制,hours:minutes:seconds的格式表示当前时间.</li>
<li>\T      以12小时制表示当前时间.</li>
<li>@      以12小时制,AM/PM格式来显示当前时间.</li>
<li>\A      以24小时制,hours:minutes格式表示当前时间.</li>
<li>\u      当前用户名.</li>
<li>\v      shell程序的版本号.</li>
<li>\V      shell程序的版本号.</li>
<li>\w      当前工作目录名.</li>
<li>\W      当前工作目录名的最后部分.</li>
<li>\!      当前命令的历史号.</li>
<li>\#      当前shell绘画中的命令数.</li>
<li>\$      这会显示一个”$”字符,除非你拥有超级用户权限.</li>
<li>\[      标志着一系列一个或多个非打印字符的开始.被用来潜入非打印的控制字符,这些字符以某种方式来操作终端仿真器,比如说移动光标或者是更改文本颜色.</li>
<li>\]      标志着非打印字符序列结束.</li>
</ul>
<h3 id="12-2-一些可替代的提示符设计"><a href="#12-2-一些可替代的提示符设计" class="headerlink" title="12.2. 一些可替代的提示符设计"></a>12.2. 一些可替代的提示符设计</h3><ul>
<li>ps1_old=”$PS1”  备份变量</li>
<li>PS1=”[\u@\h@\s\n\t \W $]”  编辑变量PS1</li>
<li>PS1=”$ps1_old”</li>
</ul>
<h3 id="12-3-添加颜色"><a href="#12-3-添加颜色" class="headerlink" title="12.3. 添加颜色"></a>12.3. 添加颜色</h3><p>字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI 转义编码来控制的。这个控制编码不会“打印”到屏幕上,而是被终端解释为一个指令。’[‘ 和 ‘]’ 序列被用来封装这些非打印字符。一个 ANSI 转义编码以一个八进制 033(这个编码是由退出按键产生的)开头,其后跟着一个可选的字符属性,在之后是一个指令。</p>
<ul>
<li><p>\033[0;30m]      Black       \033[1;30m]      Dark Gray</p>
</li>
<li><p>\033[0;31m]      Red         \033[1;31m]      Light Red</p>
</li>
<li><p>\033[0;32m]      Green       \033[1;32m]      Light Green</p>
</li>
<li><p>\033[0;33m]      Brown       \033[1;33m]      Yellow</p>
</li>
<li><p>\033[0;34m]      Blue        \033[1;34m]      Light Blue</p>
</li>
<li><p>\033[0;35m]      Purple      \033[1;35m]      Light Pur-ple</p>
</li>
<li><p>\033[0;36m]      Cyan        \033[1;36m]      Light Cyan</p>
</li>
<li><p>\033[0;37m ]     Light Gray  \033[1;37m]      White</p>
<p>  例:PS1=”[\033[0;31m]&lt;\u@\h@\s\n\t \W \$\033[0m”</p>
</li>
</ul>
<p>用转义序列来设置背景颜色</p>
<ul>
<li><p>\033[0;40m 蓝色 \033[1;44m 黑色</p>
</li>
<li><p>\033[0;41m 红色 \033[1;45m 粉红</p>
</li>
<li><p>\033[0;42m 绿色 \033[1;46m 青色</p>
</li>
<li><p>\033[0;43m 棕色 \033[1;47m 浅灰色</p>
<p>  例:PS1=’\[\033[0;41m\]&lt;\u@\h \W&gt;$\[\033[0m\] ‘<br>  注意:除了正常的 (0) 和黑体 (1) 字符属性之外,文本也可以具有下划线 (4),闪烁 (5),和反向 (7) 属性。为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性。</p>
</li>
</ul>
<h3 id="12-4-移动光标"><a href="#12-4-移动光标" class="headerlink" title="12.4. 移动光标"></a>12.4. 移动光标</h3><ul>
<li><p>\033[1;cH    把光标移动第一行,第C列.</p>
</li>
<li><p>\033[nA      把光标向上移动n行.</p>
</li>
<li><p>\033[nB      把光标向下移动n行.</p>
</li>
<li><p>\033[nC      把光标向前移动n个字符.</p>
</li>
<li><p>\033[nD      把光标向后移动n个字符.</p>
</li>
<li><p>\033[2J      清空屏幕,把光标移到左上角(第0行,第0列).</p>
</li>
<li><p>\033[K       清空从光标位置到当前行末的内容.</p>
</li>
<li><p>\033[s       存储当前光标位置.</p>
</li>
<li><p>\033[u       唤醒之前存储的光标位置.</p>
<p>  例:PS1=’[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u]<br>&lt;\u@\h \W&gt;$ ‘</p>
<p>  [          开始一个非打印字符序列.其真正的目的是为了让bash能够正确第计算提示符的大小.如果没有这个转义字符的话,命令行编辑功能会弄错光标的位置.<br>  \033[s      存储光标位置.这个用来使光标能回到原来提示符的位置.当长条和时钟显示到屏幕上方之后.当心一些终端仿真器不推崇这个编码.<br>  \033[0;0H   把光标移到屏幕左上角,也就是第0行,第0列的位置.<br>  \033[0;41m  把背景设置为红色.<br>  \033[1;33m  把文本颜色设为黄色.<br>  \t          显示当前时间.虽然这是一个可”打印”的元素,但我们仍把它包含在提示符的非打印部分,因为我们不想bash在计算可见提示符的真正大小时包含这个时钟在内.<br>  \033[0m     关闭颜色设置.这对文本和背景都起作用.<br>  \033[u      恢复到之前保存过的光标位置处.<br>  ]          结束非打印字符序列.<br>  &lt;\u@\h\W&gt;$ 提示符字符串.</p>
</li>
</ul>
<h3 id="12-5-保存提示符"><a href="#12-5-保存提示符" class="headerlink" title="12.5. 保存提示符"></a>12.5. 保存提示符</h3><pre><code>PS1=&apos;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$ &apos;</code></pre><h2 id="13-软件包管理"><a href="#13-软件包管理" class="headerlink" title="13. 软件包管理"></a>13. 软件包管理</h2><p>Linux发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性.</p>
<h3 id="13-1-打包系统"><a href="#13-1-打包系统" class="headerlink" title="13.1. 打包系统"></a>13.1. 打包系统</h3><ul>
<li>Debian Style(.deb)  Debian,Ubuntu,Xandros,Linspire</li>
<li>Red Hat Style(.rpm) Fedora,Centos,Red Hat Enterprise Linux,OpenSUSE,Mandriva,PCLinuxOS</li>
</ul>
<h3 id="13-2-软件包管理系统工作原理"><a href="#13-2-软件包管理系统工作原理" class="headerlink" title="13.2. 软件包管理系统工作原理"></a>13.2. 软件包管理系统工作原理</h3><h3 id="13-3-包文件"><a href="#13-3-包文件" class="headerlink" title="13.3. 包文件"></a>13.3. 包文件</h3><p>包文件是一个构成软件包的文件压缩集合.一个软件包可能由大量程序以及支持这些程序的数据文件组成.另外,许多软件包还包含预安装和安装后脚本.</p>
<h3 id="13-4-资源库"><a href="#13-4-资源库" class="headerlink" title="13.4. 资源库"></a>13.4. 资源库</h3><p>软件项目选择执行他们自己的打包和发布策略,但是现在大多数软件包是由发行<br>商和感兴趣的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包,这<br>个资源库可能包含了成千上万个软件包,每一个软件包都是专门为这个系统发行版建立和维护<br>的。</p>
<h3 id="13-5-依赖性"><a href="#13-5-依赖性" class="headerlink" title="13.5. 依赖性"></a>13.5. 依赖性</h3><p>程序很少是”孤立的”,而是依赖于其它软件组件来完成它们的工作.</p>
<h3 id="13-6-上层和底层软件包工具"><a href="#13-6-上层和底层软件包工具" class="headerlink" title="13.6. 上层和底层软件包工具"></a>13.6. 上层和底层软件包工具</h3><p>软件包管理系统通常由两种工具类型组成:</p>
<ul>
<li>底层工具用来处理这些任务,如安装和删除软件包文件.</li>
<li>上层工具用来完成元数据搜索和依赖解析.</li>
</ul>
<h3 id="13-7-常见软件包管理任务"><a href="#13-7-常见软件包管理任务" class="headerlink" title="13.7. 常见软件包管理任务"></a>13.7. 常见软件包管理任务</h3><h3 id="13-8-查找资源库中的软件包"><a href="#13-8-查找资源库中的软件包" class="headerlink" title="13.8. 查找资源库中的软件包"></a>13.8. 查找资源库中的软件包</h3><p>使用上层工具来搜索资源库元数据,可以根据软件包的名字和说明来定位它.</p>
<pre><code>风格        命令
Debian     apt-get update;apt-cache search search_string
Red Hat    dnf search search_string

例:dnf search emacs  通过dnf资源库来查找emacs文本编辑器.</code></pre><h3 id="13-9-从资源库中安装一个软件包"><a href="#13-9-从资源库中安装一个软件包" class="headerlink" title="13.9. 从资源库中安装一个软件包"></a>13.9. 从资源库中安装一个软件包</h3><p>上层工具允许从一个资源库中下载一个软件包,并经过完全依赖解析来安装它.</p>
<h3 id="13-10-通过软件包文件来安装软件"><a href="#13-10-通过软件包文件来安装软件" class="headerlink" title="13.10. 通过软件包文件来安装软件"></a>13.10. 通过软件包文件来安装软件</h3><p>如果从某处而不是从资源库中下载了一个软件包文件,可以使用底层工具来直接(没有经过依赖解析)安装它.</p>
<p>底层软件包安装命令</p>
<pre><code>风格       命令
Debian    dpkg --install package_file
Red Hat   rpm -i package_file</code></pre><p>注意:因为这项技术使用底层的rpm程序来执行安装任务,所以没有运行依赖解析.如果rpm程序发现缺少了一个依赖,则会报错并退出.</p>
<h3 id="13-11-卸载软件"><a href="#13-11-卸载软件" class="headerlink" title="13.11. 卸载软件"></a>13.11. 卸载软件</h3><p>可以使用上层或者底层工具来卸载软件.</p>
<p>上层工具卸载命令:</p>
<pre><code>风格      命令
Debian   apt-get remove package_name
Red Hat  yum erase package_name</code></pre><h3 id="13-12-经过资源库来更新软件包"><a href="#13-12-经过资源库来更新软件包" class="headerlink" title="13.12. 经过资源库来更新软件包"></a>13.12. 经过资源库来更新软件包</h3><p>软件包更新命令</p>
<pre><code>风格      命令
Debian   apt-get update;apt-get upgrade
Red Hat  yum update</code></pre><h3 id="13-13-经过软件包文件来升级软件"><a href="#13-13-经过软件包文件来升级软件" class="headerlink" title="13.13. 经过软件包文件来升级软件"></a>13.13. 经过软件包文件来升级软件</h3><p>可以安装非资源库网站下载的软件包最新版,用它来替代先前的版本.</p>
<p>底层软件包升级命令<br>    风格        命令<br>    Debian     dpkg –install package_file<br>    Red Hat    rpm -U package_file</p>
<pre><code>例:rpm -U emacs-22.1-7.fc7-i386.rpm</code></pre><p>注意:rpm程序安装一个软件包和升级一个软件包所用的选项是不同的,而dpkg程序所用的选项是相同的.</p>
<h3 id="13-14-列出所安装的软件包"><a href="#13-14-列出所安装的软件包" class="headerlink" title="13.14. 列出所安装的软件包"></a>13.14. 列出所安装的软件包</h3><pre><code>风格         命令
Debian      dpkg --list
Red Hat     rpm -qa</code></pre><h3 id="13-15-确定是否安装了一个软件包"><a href="#13-15-确定是否安装了一个软件包" class="headerlink" title="13.15. 确定是否安装了一个软件包"></a>13.15. 确定是否安装了一个软件包</h3><p>软件包状态命令<br>    风格           命令<br>    Debian        dpkg –status package_name<br>    Red Hat       rpm -q package_name</p>
<h3 id="13-16-显示所安装软件包的信息"><a href="#13-16-显示所安装软件包的信息" class="headerlink" title="13.16. 显示所安装软件包的信息"></a>13.16. 显示所安装软件包的信息</h3><p>查看软件包信息命令<br>    风格          命令<br>    Debian       apt-cache show package_name<br>    Red Hat      yum info package_name</p>
<h3 id="13-17-查找安装了某个文件的软件"><a href="#13-17-查找安装了某个文件的软件" class="headerlink" title="13.17. 查找安装了某个文件的软件"></a>13.17. 查找安装了某个文件的软件</h3><p>包文件识别命令</p>
<p>风格          命令<br>Debian       dpkg –search file_name<br>Red Hat      rpm -qf file_name</p>
<h2 id="14-存储媒介"><a href="#14-存储媒介" class="headerlink" title="14. 存储媒介"></a>14. 存储媒介</h2><ul>
<li>mount    挂载一个文件系统</li>
<li>umount   卸载一个文件系统</li>
<li>fsck     检查和修复一个文件系统</li>
<li>fdisk    分区表控制器</li>
<li>mkfs     创建文件系统</li>
<li>fdformat 格式化一张软盘</li>
<li>dd       把面向块的数据直接写入设备</li>
<li>genisoimage(mksiofs)    创建一个ISO 9660 的映像文件</li>
<li>wodim(cdrecord)    把数据写入光存储媒介</li>
<li>md5sum    计算MD5检验码</li>
</ul>
<h3 id="14-1-挂载和卸载存储设备"><a href="#14-1-挂载和卸载存储设备" class="headerlink" title="14.1. 挂载和卸载存储设备"></a>14.1. 挂载和卸载存储设备</h3><p>文件/etc/fstab列出系统启动时要挂载的设备.<br>/etc/fstab字段.</p>
<pre><code>字段     内容                说明
1       设备名               一般这个字段包含与物理设备相关联的设备文件的实际名字.
2       挂载点               设备所连接到的文件系统树的目录.
3       文件系统类型          linux允许挂载许多文件系统类型.
4       选项                 文件系统可以通过各种选项来挂载.
5       频率                 一位数字,指定是否和在什么时间用dump命令来备份一个文件系统.
6       次序                 一位数字,指定fsck命令按照什么次序来检查文件系统.</code></pre><h3 id="14-2-查看挂载的文件系统列表"><a href="#14-2-查看挂载的文件系统列表" class="headerlink" title="14.2. 查看挂载的文件系统列表"></a>14.2. 查看挂载的文件系统列表</h3><p>使用mount命令来挂载文件系统.执行这个不带参数的命令,将会显示一系列当前挂载的文件系统.</p>
<h3 id="14-3-确定设备名称"><a href="#14-3-确定设备名称" class="headerlink" title="14.3. 确定设备名称"></a>14.3. 确定设备名称</h3><p>Linux存储设备名称</p>
<p>/dev/fd*    软盘驱动器<br>/dev/hd*    老系统中的IDE(PATA)磁盘.典型的主板包含两个IED连接器或者是通道,每个连接器带有一根缆线,每根缆线上有来两个硬盘驱动器连接点.缆线上的第一个驱动器叫做主设备,第二个叫做从设备.<br>/dev/lp*    打印机<br>/dev/sd*    SCSI磁盘.在最近的linux系统中,内核把所有类似于磁盘的设备看作SCSI磁盘.<br>/dev/sr*    光盘(CD/DVD)读取器和烧写器.</p>
<h3 id="14-4-创建新的文件系统"><a href="#14-4-创建新的文件系统" class="headerlink" title="14.4. 创建新的文件系统"></a>14.4. 创建新的文件系统</h3><h3 id="14-5-用fdisk命令操作分区"><a href="#14-5-用fdisk命令操作分区" class="headerlink" title="14.5. 用fdisk命令操作分区"></a>14.5. 用fdisk命令操作分区</h3><p>fdisk程序允许直接在底层与类似磁盘的设备进行交互.使用这个工具可以在设备上编辑,删除和创建分区.<br>    例:U盘<br>    sudo umount /dev/sdb1    卸载U盘<br>    sudo fdisk /dev/sdb      启动程序fdisk<br>    m                        显示程序菜单<br>    p                        打印出设备的分区表<br>    l                        显示一个很长的可能类型列表<br>    b                        已存在分区类型的ID号<br>    83                       针对linux系统的ID号</p>
<h3 id="14-6-用mkfs命令创建一个新的文件系统"><a href="#14-6-用mkfs命令创建一个新的文件系统" class="headerlink" title="14.6. 用mkfs命令创建一个新的文件系统"></a>14.6. 用mkfs命令创建一个新的文件系统</h3><p>mkfs(make file system 的简写),它能创建各种格式的文件系统.</p>
<h3 id="14-7-测试和修复文件系统"><a href="#14-7-测试和修复文件系统" class="headerlink" title="14.7. 测试和修复文件系统"></a>14.7. 测试和修复文件系统</h3><p>fsck(fle system check 的简写).</p>
<ul>
<li>fsck修复受损的文件系统.</li>
<li>fsck检查文件系统的完整性.每个/etc/fstab项中的最后一个数字指定了设备的检查顺序.数字为0则相应设备不会被检查.</li>
<li>fsck修复受损的文件系统.其成功率依赖于受损怀的数量.</li>
</ul>
<h3 id="14-8-格式化"><a href="#14-8-格式化" class="headerlink" title="14.8. 格式化"></a>14.8. 格式化</h3><ul>
<li>sudo fdformat /dev/fd0</li>
<li>sudo mkfs -t msdos /dev/fd0</li>
</ul>
<h3 id="1-14-9-直接把数据移入-出设备"><a href="#1-14-9-直接把数据移入-出设备" class="headerlink" title="1.14.9. 直接把数据移入/出设备"></a>1.14.9. 直接把数据移入/出设备</h3><p>dd程序可以把数据块从一个地方复制到另一个地方.</p>
<pre><code>dd if=input_file of=output_file [bs=block_size[count=blocks]]
例:
    dd if=/dev/sdb of=/dev/sdc
    dd if=/dev/sdb of=flash_drive.img</code></pre><p>警告:dd命令非常强大.虽然它的名字来自于”数据定义”,有时候也把它叫做”清除硬盘”.因为用户经常会误输入if或of的规范.</p>
<h3 id="14-10-创建CD-ROM映像"><a href="#14-10-创建CD-ROM映像" class="headerlink" title="14.10. 创建CD-ROM映像"></a>14.10. 创建CD-ROM映像</h3><p>写入一个CD-ROM</p>
<ol>
<li>构建一个ISO映像,这就是一个CD-ROM的文件系统映像.</li>
<li>把这个映像文件写入到CD-ROM媒介中.</li>
</ol>
<h4 id="14-10-1-创建一个CD-ROM的映像拷贝"><a href="#14-10-1-创建一个CD-ROM的映像拷贝" class="headerlink" title="14.10.1. 创建一个CD-ROM的映像拷贝"></a>14.10.1. 创建一个CD-ROM的映像拷贝</h4><pre><code>dd if=/dev/cdrom of=ubuntu.iso</code></pre><p>这项技术也适用于DVD光盘,但不能用于音频CD,因为它们不是用文件系统来存储数据.(音频CD,看一下cdrdao命令).</p>
<h4 id="14-10-2-从文件集中创建一个映像"><a href="#14-10-2-从文件集中创建一个映像" class="headerlink" title="14.10.2. 从文件集中创建一个映像"></a>14.10.2. 从文件集中创建一个映像</h4><p>创建一个包含目录内容的iso映像文件,使用genisoimage程序.</p>
<ul>
<li><p>创建一个包含所有文件的目录.</p>
</li>
<li><p>执行genisoimage来创建映像文件.</p>
<p>  例:</p>
<pre><code>genisoimage -o cd-rom.iso -R -J -/cd-rom-files
-R   选项添加元数据为Rock Ridege扩展,这允许使用长文件名和POSIX风格的文件权限.
-J   选项使Joliet扩展生效.这样Windows就支持长文件名了.</code></pre></li>
</ul>
<h3 id="14-11-写入CD-ROM镜像"><a href="#14-11-写入CD-ROM镜像" class="headerlink" title="14.11. 写入CD-ROM镜像"></a>14.11. 写入CD-ROM镜像</h3><h4 id="14-11-1-直接挂载一个ISO镜像"><a href="#14-11-1-直接挂载一个ISO镜像" class="headerlink" title="14.11.1. 直接挂载一个ISO镜像"></a>14.11.1. 直接挂载一个ISO镜像</h4><ol>
<li>mkdir /mnt/iso_image</li>
<li>mount -t iso9660 -o loop image.iso /mnt/iso_image</li>
</ol>
<p>添加”-o loop”选项来挂载(同时带有必需的”-t iso9660”文件系统类型),挂载这个映像文件就好像它是一台设备,把它连接到文件系统树上.<br>这样就创建了一个挂载点叫做/mnt/iso_image,然后把此映像文件image.iso挂载到挂载点上.</p>
<h3 id="14-12-清楚一张可重写入的CD-ROM"><a href="#14-12-清楚一张可重写入的CD-ROM" class="headerlink" title="14.12. 清楚一张可重写入的CD-ROM"></a>14.12. 清楚一张可重写入的CD-ROM</h3><pre><code>wodim dev=/dev/cdrw blank=fast</code></pre><p>使用wodim命令,指定设备名称和清空的类型.</p>
<h3 id="14-13-写入镜像"><a href="#14-13-写入镜像" class="headerlink" title="14.13. 写入镜像"></a>14.13. 写入镜像</h3><pre><code>wodim dev=/dev/cdrw image.iso</code></pre><p>wodim命令的默认模式是track-at-once,这对于录制音乐很有用.<br>-v    详细输出<br>-dao  以disk-at-once模式写入光盘.</p>
<p>md5sum image.iso<br>当使用md5sum程序时,它会产生一个独一无二的十六进制数字.</p>
<h2 id="15-网络系统"><a href="#15-网络系统" class="headerlink" title="15. 网络系统"></a>15. 网络系统</h2><ul>
<li>ping        发送ICMP ECHO_REQUEST软件包到网络主机.</li>
<li>traceroute  打印到一台网络主机的路由数据包.</li>
<li>netstat     打印网络连接,路由表,接口统计数据,伪装连接和多路广播成员.</li>
<li>ftp         因特网文件传输程序.</li>
<li>wget        非交互式网络下载器.</li>
<li>ssh         OpenSSH SSH 客户端(远程登录程序).</li>
</ul>
<h3 id="15-1-检查和检测网络"><a href="#15-1-检查和检测网络" class="headerlink" title="15.1. 检查和检测网络"></a>15.1. 检查和检测网络</h3><h3 id="15-2-ping"><a href="#15-2-ping" class="headerlink" title="15.2. ping"></a>15.2. ping</h3><p>ping命令发送一个特殊的网络数据包,叫做IMCP ECHO_REQUEST,到一台指定的主机.大多数接收这个包的网络设备将会回复它,来允许网络连接验证.</p>
<p>注意:大多数网络设备(包括Linux主机)都可以被配置为忽略这些数据包.通常,这样做是处于网络安全原因,部分地遮蔽一台主机免受一个潜在攻击者地侵袭.配置防火墙来阻塞IMCP流量很普遍.</p>
<h3 id="15-3-traceroute"><a href="#15-3-traceroute" class="headerlink" title="15.3. traceroute"></a>15.3. traceroute</h3><p>traceroute程序(有些系统使用相似的tracepath程序来替代)会显示从本地到指定主机要经过的所有”跳数”的网络流量列表.对于那些提供标识信息的路由器,我们能看到它们的主机名,IP地址和性能数据,这些数据包括三次从本地到此路由器的往返时间样本.对于没有提供标识信息的路由器(由于路由器配置,网络拥塞,防火墙等方面的原因),我们会看到几个星号.</p>
<h3 id="15-4-netstat"><a href="#15-4-netstat" class="headerlink" title="15.4. netstat"></a>15.4. netstat</h3><p>netstat程序被用来检查各种各样的网络位置和统计数据.</p>
<ul>
<li>-ie       查看系统中的网络接口.<ul>
<li>eth0    因特网接口</li>
<li>lo      内部回环网络虚拟接口.系统用它来”自言自语”.</li>
<li>UP      每个网络接口第四行开头出现的”UP”,说明这个网络接口已经生效.</li>
<li>DHCP    对于使用DHCP的系统,在这个地段中的一个有效IP地址则证明DHCP工作正常.</li>
</ul>
</li>
<li>-r        显示内核的网络路由表.</li>
</ul>
<h3 id="15-5-网络中传输文件"><a href="#15-5-网络中传输文件" class="headerlink" title="15.5. 网络中传输文件"></a>15.5. 网络中传输文件</h3><h4 id="15-5-1-ftp"><a href="#15-5-1-ftp" class="headerlink" title="15.5.1. ftp"></a>15.5.1. ftp</h4><p>FTP被广泛地用来从因特网上下载文件.大多数网络浏览器都支持FTP.FTP的原始形式并不是安全的,因为它会以明码形式发送账号的姓名和密码.</p>
<pre><code>ftp fileserver      唤醒ftp程序,让它连接到FTP服务器,file-server
anonymous           登陆名.
cd pub/cd_images/Ubuntu-8.04    跳转到远端系统中,要下载的文件所在目录下.
ls                  列出远端系统中的目录.
lcd Desktop         跳转到本地系统中的~/Desktop目录下
get ubuntu-8.04-desktop-i386.iso    告诉远端系统传诵文件到本地
bye                 退出远端系统服务器,结束ftp程序会话.</code></pre><p>ftp&gt;提示符下,输入”help”会显示所支持命令的列表.</p>
<h3 id="15-6-lftp-更好的ftp"><a href="#15-6-lftp-更好的ftp" class="headerlink" title="15.6. lftp 更好的ftp"></a>15.6. lftp 更好的ftp</h3><p>ftp并不是唯一的命令行形式的FTP客户端.lftp是比较流行的ftp程序.</p>
<h3 id="15-7-wget"><a href="#15-7-wget" class="headerlink" title="15.7. wget"></a>15.7. wget</h3><p>从网络和FTP网站下载数据.</p>
<h3 id="15-8-与远程主机安全通信"><a href="#15-8-与远程主机安全通信" class="headerlink" title="15.8. 与远程主机安全通信"></a>15.8. 与远程主机安全通信</h3><p>rlogin和telnet程序拥有和ftp程序一样的知名缺点:它们以明码形式来传输所有的交流信息.</p>
<h4 id="15-8-1-1"><a href="#15-8-1-1" class="headerlink" title="15.8.1. 1"></a>15.8.1. 1</h4><p>一款新的协议SSH(Secure Shell)解决了这两个基本的和远端主机安全交流的问题.</p>
<ol>
<li>SSH认证远端主机是否为它所知道的那台主机.这样就组织了所谓的”中间人”的攻击.</li>
<li>SSH加密了本地与远程主机之间所有的通讯信息.</li>
</ol>
<p>SSH由两部分组成.</p>
<ol>
<li>SSH服务器运行在远端主机,在端口号22上监听将要到来的连接.</li>
<li>SSH客户端用在本地系统中,用来和远端服务器通信.</li>
</ol>
<h3 id="15-9-scp-和-sftp"><a href="#15-9-scp-和-sftp" class="headerlink" title="15.9. scp 和 sftp"></a>15.9. scp 和 sftp</h3><p>OpenSSH软件包也包含两个程序,它们可以利用SSH加密通道在网络间复制文件.</p>
<ol>
<li>scp(安全复制)被用来复制文件,与熟悉的cp程序非常相似.最显著的区别就是源或者目标路径名要以远端主机的名后跟着一个冒号字符开头.<br> 例:scp remote-sys:document.txt  从远端系统remote-sys的家目录下复制文档document.txt到我们本地系统的当前工作目录下.</li>
<li>sftp是ftp程序的安全替代品.sftp工作起来与我们之前使用的ftp程序很相似,然而它不用明码形式来传递数据,它使用加密的SSH通道.</li>
</ol>
<h2 id="16-查找文件"><a href="#16-查找文件" class="headerlink" title="16. 查找文件"></a>16. 查找文件</h2><pre><code>locate  通过名字来查找文件
find    在目录层次结构中搜索文件
xargs   从标准输入生成和执行命令行
touch   更改文件时间
stat    显示文件或文件系统状态</code></pre><h3 id="16-1-locate-查找文件的简单方法"><a href="#16-1-locate-查找文件的简单方法" class="headerlink" title="16.1. locate 查找文件的简单方法"></a>16.1. locate 查找文件的简单方法</h3><p>locate程序快速搜索路径名数据库,并且输出每个与给定字符串相匹配的文件名.</p>
<pre><code>例:locate /bin/zip locate 命令将会搜索它的路径名数据库,输出任一个包含字符串“bin/zip”的路径名.</code></pre><h3 id="16-2-find-查找文件的复杂方式"><a href="#16-2-find-查找文件的复杂方式" class="headerlink" title="16.2. find 查找文件的复杂方式"></a>16.2. find 查找文件的复杂方式</h3><p>find程序能基于各种各样的属性,搜索一个给定目录来查找文件.</p>
<h4 id="16-2-1-Tests"><a href="#16-2-1-Tests" class="headerlink" title="16.2.1. Tests"></a>16.2.1. Tests</h4><pre><code>例: find ~ -type d | wc -l 输出家目录列表
    find ~ -type f | wc -l 输出家目录下的普通文件</code></pre><p>find文件类型</p>
<pre><code>文件类型               描述
   b                块设备文件
   c                字符设备文件
   d                目录
   f                普通文件
   l                符号链接

例:find ~ -type f -name &quot;\*.JPG&quot; -size
 +1M | wc -l
 加入 -name 测试条件,后面跟通配符模式.双引号用来组织shell展开路径名.加入-size测试条件,后跟&quot;+1M&quot;,开头的加号表明我们正在寻找文件大小大于指定数的文件.若字符串以减号开头,则意味着查找小于指定数的文件.若没有符号意味着&quot;精确匹配这个数&quot;.结尾字母&quot;M&quot;表明测量单位是兆字节.</code></pre><p>find大小单位</p>
<pre><code>字符                单位
b               512个字节块.默认值.
c               字节
w               两个字节的字
k               千字节(1024个字节单位)
M               兆字节(1048576个字节单位)
G               千兆字节(1073741824个字节单位)</code></pre><p>find测试条件</p>
<pre><code>测试条件            描述
-cmin n         匹配的文件和目录的内容或属性最后修改时间正好在n分钟之前.指定少于n分钟之前,使用-年,指定多于n分钟之前,使用+n.
-cnewer file    匹配的文件和目录的内容或属性最后修改时间早于那些文件.
-ctime n        匹配的文件和目录的内容和属性最后修改时间在n\*24小时之前.
-empty          匹配空文件和目录.
-group name     匹配的文件和目录属于一个组.组可以用组名或组ID来表示.
-iname pattern  就像-name测试条件,但是不区分大小写.
-inum n         匹配的文件的inode号是n.这对于找到某个特殊inode的所以有硬链接很有帮助.
-mmin n         匹配的文件或目录的内容被修改于n分钟之前.
-mtime n        匹配的文件或目录的内容被修改于n\*24小时之前.
-name pattern   用指定的通配符模式匹配的文件和目录.
-newer file     匹配的文件和目录的内容早于指定的文件.当编写shell脚本,做文件备份时,非常有帮助.每次你制作一个备份,更新文件,然后使用find名来来决定自赏赐更新,哪一个文件已经更改了.
-nouser         匹配的文件和目录不属于一个有效的用户.
-perm mode      匹配的文件和目录的权限已经设置为指定的mode.
-samefile name  相似于-inum测试条件.匹配和文件name享有同样inode号的文件.
-size n         匹配的文件大小为n.
-user name      匹配的文件或目录属于某个用户.这个用户可以通过用户名或用户ID来表示.</code></pre><p>find命令手册有更详细的说明.</p>
<h3 id="16-3-操作符"><a href="#16-3-操作符" class="headerlink" title="16.3. 操作符"></a>16.3. 操作符</h3><p>find命令的逻辑操作符</p>
<ul>
<li>-and      如果操作符两边的测试条件都是真,则匹配.可以简写为-a.注意若没有使用操作符,则默认使用-and.</li>
<li>-or       若操作符两边的任一个测试条件为真,则匹配.可以简写为-o.</li>
<li>-not      若操作符后面的测试条件是真,则匹配.可以简写为一个感叹号(!).</li>
<li>()        把测试条件和操作符组合起来形成更更大的表达式.这用来控制逻辑计算的优先级.默认情况下,find命令按照从左到右的顺序计算.</li>
</ul>
<h3 id="16-4-预定以的操作"><a href="#16-4-预定以的操作" class="headerlink" title="16.4. 预定以的操作"></a>16.4. 预定以的操作</h3><p>几个预定义的find命令操作</p>
<ul>
<li><p>-delete   删除当前匹配的文件.</p>
</li>
<li><p>-ls       对匹配的文件执行等同的ls -dils命令.并将结果发送到标准输出.</p>
</li>
<li><p>-print    把匹配文件的全路径名输送到标准输出.如果没有指定其它操作,这是默认操作.</p>
</li>
<li><p>-quit     一旦找到一个匹配,退出.</p>
<p>  例:find ~</p>
<pre><code>find ~ -print
find ~ -type f -name &apos;*.BAK&apos; -delete
find ~ -type f -name &apos;*.BAK&apos; -print
find ~ -type f -and -name &apos;*.BAK&apos; -and -print</code></pre></li>
</ul>
<h3 id="16-5-用户定义的行为"><a href="#16-5-用户定义的行为" class="headerlink" title="16.5. 用户定义的行为"></a>16.5. 用户定义的行为</h3><p>-exec command{}<br>这里的command就是指一个命令的名字,{}是当前路径名的符号表示,分号是要求的界定符表明命令结束.</p>
<pre><code>例:find ~ -type f -name &apos;foo*&apos; -ok ls -l &apos;{}&apos; &apos;;&apos;
花括号和分号对于 shell 有特殊含义,所以它们必须被引起来或被转义。
在这个例子里面,我们搜索以字符串“foo”开头的文件名,并且对每个匹配的文件执行 ls</code></pre><p>-l 命令。通过使用 -ok 行为来代替 -exec,会在 ls 命令执行之前提示用户。</p>
<h3 id="16-6-提高效率"><a href="#16-6-提高效率" class="headerlink" title="16.6. 提高效率"></a>16.6. 提高效率</h3><p>当 -exec 行为被使用的时候,若每次找到一个匹配的文件,它会启动一个新的指定命令的实<br>例。我们可能更愿意把所有的搜索结果结合起来,再运行一个命令的实例。</p>
<pre><code>例:find ~ -type f -name &apos;foo*&apos; -exec ls -l &apos;{}&apos; &apos;;&apos;

通过把末尾的分号改为加号,就激活了 find 命令的一个功能,把搜索结果结合为一个参数</code></pre><p>列表,然后执行一次所期望的命令。</p>
<pre><code>例:find ~ -type f -name &apos;foo*&apos; -exec ls -l &apos;{}&apos; +</code></pre><h3 id="16-7-xargs"><a href="#16-7-xargs" class="headerlink" title="16.7. xargs"></a>16.7. xargs</h3><p>xargs命令会执行一个有趣的函数.它从标准输入接受输入,并把输入转换为一个特定命令的参数列表.<br>注意:当被放置到命令行中的参数个数相当大时,参数个数是有限制的.有可能创建的命令太长以至于shell不能接受.当命令行超过系统支持的最大长度时,xargs会执行带有最大参数个数的指定命令,然后重复这个过程直到耗尽标准输入.执行带有-show-limits选项的xargs命令,来查看命令行的最大值.</p>
<pre><code>例:find ~ -type f -name &apos;foo\*&apos; -print | xargs ls -l</code></pre><h3 id="16-8-返回操练场"><a href="#16-8-返回操练场" class="headerlink" title="16.8. 返回操练场"></a>16.8. 返回操练场</h3><h3 id="16-9-选项"><a href="#16-9-选项" class="headerlink" title="16.9. 选项"></a>16.9. 选项</h3><p>find命令选项</p>
<ul>
<li>-depth    指导find程序先处理目录中的文件,再处理目录自身.当指定-delete行为时,会自动应用这个选项.</li>
<li>-maxdepth levels  当执行测试条件和行为的时候,设置find程序陷入目录树的最大级别数.</li>
<li>-mindepth levels  在应用测试条件和行为之前,设置find程序陷入目录数的最小级别数.</li>
<li>-mount            指导find程序不要搜索挂载到其它文件系统上的目录.</li>
<li>-noleaf           指导find程序不要基于搜索雷Unix的文件系统做出的假设,来优化它的搜索.</li>
</ul>
<h2 id="17-归档和备份"><a href="#17-归档和备份" class="headerlink" title="17. 归档和备份"></a>17. 归档和备份</h2><p>文件压缩程序:</p>
<ul>
<li>gzip  压缩或者展开文件</li>
<li>bzip2 块排序文件压缩器</li>
</ul>
<p>归档程序:</p>
<ul>
<li>tar   磁带打包工具</li>
<li>zip   打包和压缩文件</li>
</ul>
<p>文件同步程序:</p>
<ul>
<li>rsync 同步远端文件和目录</li>
</ul>
<h3 id="17-1-压缩文件"><a href="#17-1-压缩文件" class="headerlink" title="17.1. 压缩文件"></a>17.1. 压缩文件</h3><p>数据压缩就是一个删除冗余数据的过程.<br>压缩算法分为两大类,无损压缩和有损压缩.</p>
<h4 id="17-1-1-gzip"><a href="#17-1-1-gzip" class="headerlink" title="17.1.1. gzip"></a>17.1.1. gzip</h4><p>gzip程序被用来压缩一个或多个文件.当执行gzip命令时,则原始文件的压缩版会替代原始文件.<br>gunzip程序被用来把压缩文件复原为没有被压缩的版本.</p>
<p>gzip选项</p>
<ul>
<li>-c    把输出写入到标准输出,并且保留原始文件.也可能用–stdout和–to-stdout选项来指定.</li>
<li>-d    解压缩.正如gunzip命令一样.也可以用–decompress或者–uncompress选项来指定.</li>
<li>-f    强制压缩,即使原始文件的压缩文件已经存在了,也要执行.也可以用–force选项来指定.</li>
<li>-h    显示用法信息.也可以用–help选项来指定.</li>
<li>-l    列出每个被压缩文件的压缩数据.也可用–list选项.</li>
<li>-r    若命令的一个或多个参数是目录,则递归第压缩目录中的文件.也可以用–recursive选项来指定.</li>
<li>-t    测试压缩文件的完整性.也可以用–test选项来指定.</li>
<li>-v    显示压缩过程中的信息.也可以用–verbose选项来指定.</li>
<li>-number   设置压缩指数.number是一个在1(最快,最小压缩)到9(最慢,最大压缩)之间的整数.数值1和9也可以各自用–fast和–best选项来表示.默认值是整数6.</li>
</ul>
<h4 id="17-1-2-bzip2"><a href="#17-1-2-bzip2" class="headerlink" title="17.1.2. bzip2"></a>17.1.2. bzip2</h4><p>bzip2程序使用了不同的压缩算法,舍弃了压缩速度,而实现了更高的压缩级别.<br>bzip2 程序使用起来和 gzip 程序一样。我们之前讨论的 gzip 程序的<br>所有选项(除了 -r),bzip2 程序同样也支持。注意,然而,压缩级别选项(-number)对于<br>bzip2 程序来说,有少许不同的含义。伴随着 bzip2 程序,有 bunzip2 和 bzcat 程序来解压缩<br>文件。bzip2 文件也带有 bzip2recover 程序,其会试图恢复受损的.bz2 文件。</p>
<h3 id="17-2-归档文件"><a href="#17-2-归档文件" class="headerlink" title="17.2. 归档文件"></a>17.2. 归档文件</h3><p>归档就是手机许多文件并把它们捆绑成一个大文件的过程.</p>
<h4 id="17-2-1-tar"><a href="#17-2-1-tar" class="headerlink" title="17.2.1. tar"></a>17.2.1. tar</h4><p>tar(tape archive的简称)是一款制作磁带备份的工具.而它仍然被用来完成传统任务,它也同样适用于其它的存储设备.”.tar”表示普通的tar包.”.tgz”表示被gzip程序压缩过的tar包.</p>
<pre><code>tar mode[options] pathname...</code></pre><p>部分tar的mode</p>
<ul>
<li>c     为文件和/或目录列表创建归档文件.</li>
<li>x     抽取归档文件.</li>
<li>r     追加具体的路径到归档文件的末尾.</li>
<li>t     列出归档文件的内容.</li>
</ul>
<h3 id="17-3-zip"><a href="#17-3-zip" class="headerlink" title="17.3. zip"></a>17.3. zip</h3><p>zip程序既是压缩工具,也是打包工具.</p>
<pre><code>zip options zipfile file...

例: zip -r playground.zip playground
    unzip ../playground.zip
    unzip -l playground.zip playground/dir-87/file-ZArchive: ../playground.zip</code></pre><p>对于zip命令要注意一点,就是如果制定了一个已经存在的文件包,其被更新而不是被替代.这意味着就保留此文件包,但是会添加新文件,同时替换匹配的文件.</p>
<h3 id="17-4-同步文件和目录"><a href="#17-4-同步文件和目录" class="headerlink" title="17.4. 同步文件和目录"></a>17.4. 同步文件和目录</h3><p>rsync option source destination</p>
<p>这里source和destination是下列选项之一:</p>
<ul>
<li>一个本地文件或目录</li>
<li>一个远端文件或目录,以[user@]host:[path的形式存在</li>
<li>一个远端rsync服务器,由rsync://[user@]host[:port]/path指定</li>
</ul>
<p>注意source和destination两者之一必须是本地文件.rsync不支持远端到远端的复制.</p>
<h2 id="18-正则表达式"><a href="#18-正则表达式" class="headerlink" title="18. 正则表达式"></a>18. 正则表达式</h2><p>正则表达式是一种符号表示法,被用来识别文本模式.在某种程度上,他们与匹配文件和路径名的shell通配符比较相似,但其规模更庞大.</p>
<h3 id="18-1-grep"><a href="#18-1-grep" class="headerlink" title="18.1. grep"></a>18.1. grep</h3><p>grep(global regular expression print的简写).</p>
<pre><code>grep [options] regex [file...]</code></pre><p>这里的regx是指regular expression,一个正则表达式.</p>
<p>常用的grep选项列表:</p>
<ul>
<li>-i        忽略大小写.不会区分大小写字符.也可用–ignore-case来指定.</li>
<li>-v        不匹配.通常,grep程序会打印包含匹配项的文本行.这个选项导致grep程序只会不包含匹配项的文本行.也可以使用–invert-match指定.</li>
<li>-c        打印匹配的数量(或者是不匹配的数目,若指定了-v选项),而不是文本行本身.也可用–count选项来指定.</li>
<li>-l        打印包含匹配项的文件名,而不是文本行本身,也可用–files-with-matches选项来指定.</li>
<li>-L        相似于-l选项,但是只是打印不包含匹配项的文件名.也可用–files-without-match来指定.</li>
<li>-n        在么哥匹配行之前大引出其位于文件中的相应行号.也可用–line-number选项来指定.</li>
<li>-h        应用于多文件搜索,不输出文件名.可用–no-filename选项来指定.</li>
</ul>
<h3 id="18-2-元字符和文本"><a href="#18-2-元字符和文本" class="headerlink" title="18.2. 元字符和文本"></a>18.2. 元字符和文本</h3><p>正则表达式元字符由  ^ $ . [ ] { } - ? * + ( ) | \ 组成.然后其它所有字符都被认为是原义字符,虽然在个别情况下,反斜杠会被用来创建元序列,<br>也允许元字符被转义为原义字符,而不是被解释为元字符。</p>
<h3 id="18-3-任何字符"><a href="#18-3-任何字符" class="headerlink" title="18.3. 任何字符"></a>18.3. 任何字符</h3><p>圆点字符被用来匹配任意字符.如果我们在正则表达式中包含它,它将会匹配在此位置的任意一个字符.<br>    例:grep -h ‘.zip’ dirlist*.txt</p>
<h3 id="18-4-锚点"><a href="#18-4-锚点" class="headerlink" title="18.4. 锚点"></a>18.4. 锚点</h3><p>在正则表达式中,插入符号和美元符号被看作是锚点.这意味着正则表达式只有在文本行的开头或末尾被找到时,才算发生一次匹配.</p>
<pre><code>例:grep -h &apos;^zip&apos; dirlist*.txt
   grep -h &apos;zip$&apos; dirlist*.txt
   grep -h &apos;^zip$&apos; dirlist*.txt
   grep -i &apos;^..j.r$&apos; /usr/share/dict/words</code></pre><h3 id="18-5-中括号表达式和字符类"><a href="#18-5-中括号表达式和字符类" class="headerlink" title="18.5. 中括号表达式和字符类"></a>18.5. 中括号表达式和字符类</h3><p>通过使用中括号表达式,我们也能够从一个指定的字符集合中匹配一个单个的字符.通过中括号表达式,我们能够制定一个字符集合(包含在不加中括号的情况下会被解释为元字符的字符)来被匹配.<br>一个字符集合包含任意多个字符,并且元字符被放置到中括号里面会失去它们的特殊含义.然而,在良好宗情况下,会在中括号表达式中使用元字符,并且有着不同的含义.第一个元字符是插入字符,其被用来表示否定;第二个是连字符字符,其被用来表示一个字符区域.</p>
<h3 id="18-6-否定"><a href="#18-6-否定" class="headerlink" title="18.6. 否定"></a>18.6. 否定</h3><p>通过在正则表达式中的第一个字符为插入字符”^”,则剩余的字符被看作是不会在给定的字符位置出现的字符集合.</p>
<pre><code>grep -h &apos;[^bg]zip&apos; dirlist*.txt
通过激活否定操作得到文件列表.否定的字符集仍然在给定位置要求一个字符,但是这个字符必须不是否定字符集的成员.</code></pre><h3 id="18-7-传统的字符区域"><a href="#18-7-传统的字符区域" class="headerlink" title="18.7 传统的字符区域"></a>18.7 传统的字符区域</h3><p>通过使用一个三字符区域,我们能够所写26个字母.任意字符的区域都能按照这种方式表达,包括多个区域,如字母和数字.</p>
<pre><code>grep -h &apos;^[A-Za-z0-9]&apos; dirlist*.txt

例:grep -h &apos;[A-Z]&apos; dirlist*.txt
这会匹配包含一个大写字母的文件名.
   grep -h &apos;[-AZ]&apos; dirlist*.txt
这个表达式会匹配包含一个连字符,或一个大写字母&quot;A&quot;,或一个大写字母&quot;Z&quot;的文件名.</code></pre><h3 id="18-8-POSIX-字符集"><a href="#18-8-POSIX-字符集" class="headerlink" title="18.8 POSIX 字符集"></a>18.8 POSIX 字符集</h3><p>POSIX 字符集</p>
<pre><code>  字符集          说明
[:alnum:]       字母数字字符.在ASCII中,等价于:[A-Za-z0-9]
[:word:]        与[:alnum:]相同,但增加了下划线字符.
[:alpha:]       字母字符.在ASCII中,等价于:[A-Za-z]
[:blank:]       包含空格和tab字符.
[:cntrl:]       ASCII的控制码.包含了0到31,和127的ASCII字符.
[:digit:]       数字0-9
[:graph:]       可视字符.在ASCII中,它包含33到126的字符.
[:lower:]       小写字母.
[:punct:]       标点符号字符.在ASCII中,等价于:
[:print:]       可打印的字符.在[:graph:]中的所有字符,再加上空格字符.
[:space:]       空白字符,包含空格,tab,回车,换行,vertical tab,和form feed.在ASCII中,等价于:[\t\r\n\v\f]
[:upper:]       大写字母.
[:xdigit:]      用来表示十六进制数字的字符.在ASCII中,等价于:[0-9A-Fa-f]

例: [me@linuxbox ~]$ ls /usr/sbin/[A-Z]*
    ls /usr/sbin/[[:upper:]]*</code></pre><h3 id="18-9-POSIX基本的Vs-扩展的正则表达式"><a href="#18-9-POSIX基本的Vs-扩展的正则表达式" class="headerlink" title="18.9 POSIX基本的Vs.扩展的正则表达式"></a>18.9 POSIX基本的Vs.扩展的正则表达式</h3><p>POSIX把正则表达式的实现分成了两类:基本正则表达式(BRE)和扩展的正则表达式(ERE).<br>BRE辨别以下元字符: ^ $ . [ ] * 其它的所有字符被认为是文本字符.<br>ERE添加了以下元字符(以及与其相关的功能): ( ) { } ? + | 在BRE中,字符”(“,”)”,”{“,”}”用反斜杠转义后,被看作是元字符,相反在ERE中,在任意元字符之前加上反斜杠会导致其被看作是一个文本字符.</p>
<h3 id="18-10-Alternation"><a href="#18-10-Alternation" class="headerlink" title="18.10 Alternation"></a>18.10 Alternation</h3><p>扩展表达式的特性之一alternation(交替).它允许从一系列字符串或者是其它的正则表达式中选择匹配项.</p>
<pre><code>例: echo &quot;AAA&quot; | grep -E &apos;AAA|BBB&apos;</code></pre><p>这里的正则表达式’AAA|BBB’,意味着”匹配字符串AAA或者是字符串BBB”.<br>注意因为这是一个扩展的特性,我们给grep命令(虽然我们能以egrep程序来代替)添加了-E选项,并且我们把这个正则表达式用单引号引起来,为的是阻止shell把竖杠线元字符解释为一个pipe操作符.Alternation并不局限于两种选择:echo “AAA” | grep -E ‘AAA|BBB|CCC’</p>
<p>为了把 alternation 和其它正则表达式元素结合起来,我们可以使用 () 来分离 alternation。</p>
<pre><code>例:grep -Eh &apos;^(bz|gz|zip)&apos; dirlist*.txt</code></pre><p>这个表达式将会在我们的列表中匹配以“bz”,或“gz”,或“zip”开头的文件名。如果我<br>们删除了圆括号,这个表达式的意思:grep -Eh ‘^bz|gz|zip’ dirlist*.txt  .会变成匹配任意以“bz”开头,或包含“gz”,或包含“zip”的文件名。</p>
<h3 id="18-11-限定符"><a href="#18-11-限定符" class="headerlink" title="18.11 限定符"></a>18.11 限定符</h3><p>扩展的正则表达式支持几种方法,来指定一个元素被匹配的次数.</p>
<h4 id="18-11-1-匹配零个或一个元素"><a href="#18-11-1-匹配零个或一个元素" class="headerlink" title="18.11.1 ? 匹配零个或一个元素"></a>18.11.1 ? 匹配零个或一个元素</h4><p>这个限定符意味着,实际上,”使前面的元素可有可无”.</p>
<h4 id="18-11-2-匹配零个或多个元素"><a href="#18-11-2-匹配零个或多个元素" class="headerlink" title="18.11.2 * 匹配零个或多个元素"></a>18.11.2 * 匹配零个或多个元素</h4><p>这个限定符被用来表示一个可选的字符,匹配的字符可以出现任意多次,不仅是一次.</p>
<pre><code>[[:upper:]][[:upper:][:lower:] ]*.</code></pre><p>这个表达式由三个元素组成:一 个 包 含 [:upper:] 字 符 集 的 中 括 号 表 达 式,一 个 包 含<br>[:upper:] 和 [:lower:] 两个字符集以及一个空格的中括号表达式,和一个被反斜杠字符转义过的<br>圆点。第二个元素末尾带有一个 * 元字符,所以在开头的大写字母之后,可能会跟随着任意数<br>目的大写和小写字母和空格,并且匹配.</p>
<pre><code>例: echo &quot;This works.&quot; | grep -E &apos;[[:upper:]][[:upper:][[:lower:]]*.&apos;</code></pre><h4 id="18-11-3-匹配一个或多个元素"><a href="#18-11-3-匹配一个或多个元素" class="headerlink" title="18.11.3 + - 匹配一个或多个元素"></a>18.11.3 + - 匹配一个或多个元素</h4><p>这个+元字符的作用与*相似,除了它要求前面的元素至少出现一次匹配.这个正则表达式只匹配那些由一个或多个字母字符组构成的文本行,字母字符之间由单个空格分开:</p>
<h4 id="18-11-4-匹配特定个数的元素"><a href="#18-11-4-匹配特定个数的元素" class="headerlink" title="18.11.4 { } 匹配特定个数的元素"></a>18.11.4 { } 匹配特定个数的元素</h4><p>{ 和 } 元字符被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指<br>定:</p>
<pre><code>限定符              意思
n               匹配前面的元素,如果它确切地出现了n次.
n,m             匹配前面的元素,如果它至少出现了n次,但是不多于m次
n,              匹配前面的元素,如果它出现了n次或多于n次.
,m              匹配前面的元素,如果它出现的次数不多于m次.

例: ^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
简化为: ^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$
grep -Ev &apos;^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$&apos;
这里我们使用 -v 选项来产生相反的匹配,因此我们将只输出不匹配指定表达式的文本行。</code></pre><p>这个表达式自身的两端都包含定位点(锚)元字符,是为了确保这个号码的两端没有多余的字<br>符。这个表达式也要求圆括号出现在一个有效的号码中,不同于我们先前电话号码的实例。</p>
<h3 id="18-12-用find查找文件名"><a href="#18-12-用find查找文件名" class="headerlink" title="18.12 用find查找文件名"></a>18.12 用find查找文件名</h3><p>当某一行包含的字符串匹配上了一个表达式的时<br>候,grep 命令会打印出这一行,然而 find 命令要求路径名精确地匹配这个正则表达式。</p>
<pre><code>例:find . -regex &apos;.*[^-\_./0-9a-zA-Z].*&apos;</code></pre><p>这样一种扫描会发现包含空格和其它潜在不规范字符的路径名.由于要精确地匹配整个路径名,所以我们在表达式的两端使用了.*,来匹配零个或多个字<br>符。在表达式中间,我们使用了否定的中括号表达式,其包含了我们一系列可接受的路径名字<br>符。</p>
<h3 id="18-13-用locate查找文件"><a href="#18-13-用locate查找文件" class="headerlink" title="18.13 用locate查找文件"></a>18.13 用locate查找文件</h3><p>这个 locate 程序支持基本的(–regexp 选项)和扩展的(–regex 选项)正则表达式。</p>
<pre><code>例:locate --regex &apos;bin/(bz|gz|zip)&apos;</code></pre><p>通过使用 alternation,我们搜索包含 bin/bz,bin/gz,或/bin/zip 字符串的路径名。</p>
<h3 id="18-14-在less和vim中查找文本"><a href="#18-14-在less和vim中查找文本" class="headerlink" title="18.14 在less和vim中查找文本"></a>18.14 在less和vim中查找文本</h3><p>less 和 vim 两者享有相同的文本查找方法。按下/按键,然后输入正则表达式,来执行搜索<br>任务。</p>
<pre><code>例:/^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$</code></pre><h3 id="1-19-文本处理"><a href="#1-19-文本处理" class="headerlink" title="1.19 文本处理"></a>1.19 文本处理</h3><ul>
<li>cat 连接文件并且打印到标准输出</li>
<li>sort 给文本行排序</li>
<li>uniq 报告或者省略重复行</li>
<li>cut 从每行中删除文本区域</li>
<li>paste 合并文件文本行</li>
<li>join 基于某个共享字段来联合两个文件的文本行</li>
<li>comm 逐行比较两个有序文件.</li>
<li>diff 逐行比较文件</li>
<li>patch 给原始文件打补丁</li>
<li>tr 翻译或删除字符</li>
<li>sed 用于筛选和转换文本的流编辑器</li>
<li>aspell 交互式拼写检查器</li>
</ul>
<h4 id="19-1-文本应用程序"><a href="#19-1-文本应用程序" class="headerlink" title="19.1 文本应用程序"></a>19.1 文本应用程序</h4><p>vim | nano | less |</p>
<h5 id="19-1-1-文档"><a href="#19-1-1-文档" class="headerlink" title="19.1.1 文档"></a>19.1.1 文档</h5><p>一个流行的方法是先用文本格式来编写一个大的文档,然后使用一种标记语言来描述已完成文档的格式.</p>
<h5 id="19-1-2-网页"><a href="#19-1-2-网页" class="headerlink" title="19.1.2 网页"></a>19.1.2 网页</h5><p>HTML | XML</p>
<h5 id="19-1-3-电子邮件"><a href="#19-1-3-电子邮件" class="headerlink" title="19.1.3 电子邮件"></a>19.1.3 电子邮件</h5><p>通过下载一个email信息,用less来浏览它.开始于标题,其描述信息的来源及传输过程中接受到的处理,然后是信息的正文内容.</p>
<h5 id="19-1-4-打印输出"><a href="#19-1-4-打印输出" class="headerlink" title="19.1.4 打印输出"></a>19.1.4 打印输出</h5><p>输出会以纯文本格式发送到打印机,或者如果页面包含图形,其会被转换成一种文本格式的页面描述语言.</p>
<h5 id="19-1-5-程序源码"><a href="#19-1-5-程序源码" class="headerlink" title="19.1.5 程序源码"></a>19.1.5 程序源码</h5><p>程序源代码,程序员实际编写的一部分程序,总是文本格式.</p>
<h3 id="19-2-回顾一些老朋友"><a href="#19-2-回顾一些老朋友" class="headerlink" title="19.2 回顾一些老朋友"></a>19.2 回顾一些老朋友</h3><h4 id="19-2-1-cat"><a href="#19-2-1-cat" class="headerlink" title="19.2.1 cat"></a>19.2.1 cat</h4><h4 id="19-2-2-sort"><a href="#19-2-2-sort" class="headerlink" title="19.2.2 sort"></a>19.2.2 sort</h4><p>sort程序能接受命令行中的多个文件作为参数,所以有可能把多个文件合并成一个有序的文件.</p>
<h4 id="19-2-3-uniq"><a href="#19-2-3-uniq" class="headerlink" title="19.2.3 uniq"></a>19.2.3 uniq</h4><p>uniq会删除任意重复行,并且把结果发送到标准输出.它常常和sort程序一块使用,来清理重复的输出.</p>
<h3 id="19-3-切片和切块"><a href="#19-3-切片和切块" class="headerlink" title="19.3 切片和切块"></a>19.3 切片和切块</h3><h4 id="19-3-1-cut"><a href="#19-3-1-cut" class="headerlink" title="19.3.1 cut"></a>19.3.1 cut</h4><p>cut程序被用来从文本行中抽取文本,并把其输出到标准输出.它能接受多个文件参数或者标准输入.</p>
<h4 id="19-3-2-paste"><a href="#19-3-2-paste" class="headerlink" title="19.3.2 paste"></a>19.3.2 paste</h4><p>paste命令会添加一个或多个文本列到文件中,而不是从文件中抽取文本列.</p>
<h4 id="19-3-3-join"><a href="#19-3-3-join" class="headerlink" title="19.3.3 join"></a>19.3.3 join</h4><p>一个join操作通常与关系型数据库有关联,在关系型数据库中来自多个享有共同关键域的表哥的数据结合起来,得到一个结果.</p>
<h3 id="1-20-比较文本"><a href="#1-20-比较文本" class="headerlink" title="1.20 比较文本"></a>1.20 比较文本</h3><h4 id="20-1-comm"><a href="#20-1-comm" class="headerlink" title="20.1 comm"></a>20.1 comm</h4><p>comm程序会比较两个文本文件,并且会显示每个文件特有的文本行和共有的文本行.</p>
<h4 id="20-2-diff"><a href="#20-2-diff" class="headerlink" title="20.2 diff"></a>20.2 diff</h4><p>diff程序被用来检测文件之间的差异.它支持许多输出格式,并且一次能处理许多文本文件.</p>
<h4 id="20-3-patch"><a href="#20-3-patch" class="headerlink" title="20.3 patch"></a>20.3 patch</h4><p>patch程序将更改应用到文本文件中.它接受从difff程序的输出,并且通常被用来把较老的文件版本转变为较新的文件版本.<br>使用diff/patch组合提供了两个重大优点:</p>
<ol>
<li><p>diff文件相较于整个源码树来说非常小.</p>
</li>
<li><p>diff文件简洁地显示了所作的修改,从而允许程序补丁的审阅者能快速地评估它.</p>
<p> diff -Naur old_file new_file &gt; diff_file</p>
</li>
</ol>
<h3 id="20-4-运行时编辑"><a href="#20-4-运行时编辑" class="headerlink" title="20.4 运行时编辑"></a>20.4 运行时编辑</h3><h4 id="20-4-1-tr"><a href="#20-4-1-tr" class="headerlink" title="20.4.1 tr"></a>20.4.1 tr</h4><p>tr程序被用来更改字符.可以看作是一种基于字符的查找和替换操作.</p>
<h4 id="20-4-2-sed"><a href="#20-4-2-sed" class="headerlink" title="20.4.2 sed"></a>20.4.2 sed</h4><p>sed 是 stream editor (流编辑器)的简称.它对文本流进行编辑.</p>
<h4 id="20-4-3-aspell"><a href="#20-4-3-aspell" class="headerlink" title="20.4.3 aspell"></a>20.4.3 aspell</h4><p>aspell是一款交互式的拼写检查器.</p>
<h2 id="1-21-格式化输出"><a href="#1-21-格式化输出" class="headerlink" title="1.21 格式化输出"></a>1.21 格式化输出</h2><ul>
<li>nl        添加行号</li>
<li>fold      限制文件列宽</li>
<li>fmt       一个简单的文本格式转换器</li>
<li>pr        让文本为打印做好准备</li>
<li>printf    格式化数据并打印出来</li>
<li>groff     一个文件格式系统</li>
</ul>
<h3 id="21-1-简单的格式化工具"><a href="#21-1-简单的格式化工具" class="headerlink" title="21.1 简单的格式化工具"></a>21.1 简单的格式化工具</h3><h4 id="21-1-1-nl-添加行号"><a href="#21-1-1-nl-添加行号" class="headerlink" title="21.1.1 nl 添加行号"></a>21.1.1 nl 添加行号</h4><p>nl程序被用作一个简单的任务.它添加文件的行数.在它最简单的用途中,它相当于cat -n</p>
<h4 id="21-1-2-fold-限制文件行宽"><a href="#21-1-2-fold-限制文件行宽" class="headerlink" title="21.1.2 fold 限制文件行宽"></a>21.1.2 fold 限制文件行宽</h4><p>折叠是将文本的行限制到特定的宽的过程.fold接受一个或多个文件及标准输入.</p>
<h4 id="21-1-3-fmt-一个简单的文本格式器"><a href="#21-1-3-fmt-一个简单的文本格式器" class="headerlink" title="21.1.3 fmt 一个简单的文本格式器"></a>21.1.3 fmt 一个简单的文本格式器</h4><p>fmt程序同样折叠文本,外加很多功能.它接受文本或标准输入并且在文本流上呈现照片转换.</p>
<h2 id="1-22-在linux下打印"><a href="#1-22-在linux下打印" class="headerlink" title="1.22 在linux下打印"></a>1.22 在linux下打印</h2><p>linux系统采用两套软件配合显示和管理打印.</p>
<ol>
<li>CUPS(Common Unix Printing System,一般Unix打印系统),用于提供打印驱动和打印任务管理;</li>
<li>,Ghostscript,一种PostScript解析器,作为RIP使用.</li>
</ol>
<ul>
<li>pr        转换需要打印的文本文件</li>
<li>lpr       打印文件</li>
<li>lp        打印文件(System V)</li>
<li>a2ps      为PostScript打印机格式化文件</li>
<li>lpstat    显示打印机状态信息</li>
<li>lpq       显示打印机队列状态</li>
<li>lprm      取消打印任务</li>
<li>cancel    取消打印任务(System V)</li>
</ul>
<h2 id="1-23-编译程序"><a href="#1-23-编译程序" class="headerlink" title="1.23 编译程序"></a>1.23 编译程序</h2><ol>
<li><p>可用性.</p>
</li>
<li><p>及时性.</p>
<p> make 维护程序的工具</p>
</li>
</ol>
<h3 id="23-1-什么是编译"><a href="#23-1-什么是编译" class="headerlink" title="23.1 什么是编译"></a>23.1 什么是编译</h3><p>编译就是把源码(一个由程序员编写的人类可读的程序描述)翻译成计算机处理器的母语的过程.<br>用汇编语言编写的程序通过汇编器处理为机器语言.<br>高级编程语言让程序员更专注于解决手头的问题.用高级语言编写的程序,经过另一个称为编译器的程序处理,会转换成机器语言.一些编译器把高级指令翻译成汇编语言,然后使用一个汇编器翻译成机器语言的最后阶段.</p>
<h4 id="23-1-1-所有程序都是可编译的吗"><a href="#23-1-1-所有程序都是可编译的吗" class="headerlink" title="23.1.1 所有程序都是可编译的吗"></a>23.1.1 所有程序都是可编译的吗</h4><p>不是的.像shell,Python,PHP,Ruby和许多其它语言是用脚本或解释型语言编写的.<br>脚本语言由一个叫做解释器的特殊程序执行.一个解释器输入程序文件,读取并执行程序中包含的每条指令.<br>通常解释型程序执行起来要比编译程序慢很多.这是一位内每次解释型程序执行时,程序中每条源码指令都需要翻译,而一个编译程序,一条源码指令只翻译一次,翻译后的指令会永久地记录到最终的执行文件中.<br>解释型语言的优势是开发解释型程序要比编译程序快速且容易.</p>
<h3 id="23-2-编译一个C语言"><a href="#23-2-编译一个C语言" class="headerlink" title="23.2 编译一个C语言"></a>23.2 编译一个C语言</h3><p>通过gcc和make编译.</p>
<pre><code>mkdir src
cd src
ftp ftp.gnu.org
anonymous
cd gnu/diction
ls
get diction-1.11.tar.gz
bye</code></pre><p>注意:因为我们是这个源码的”维护者”,当我们编译它的时候,我们把它保存在~/src目录下.由你的系统发行版源码会把源码安装在/usr/src目录下,而供多个用户使用的源码,通常安装在/usr/local/src目录下.<br>解压tar</p>
<pre><code>tar xzf diction-1.11.tar.gz</code></pre><p>当源码tar文件打开的时候,会创建一个目录,该目录包含了源码树,并且这个目录将会命名为project-x.xx,其包含了项目名称和它的版本号两项内容.<br>这种方案能在系统中方便安装同一个程序的多个版本.</p>
<p>在解压前检查tar文件的内容:</p>
<pre><code>tar tzvf tarfile | head ---</code></pre><h3 id="23-3-检查源码树"><a href="#23-3-检查源码树" class="headerlink" title="23.3 检查源码树"></a>23.3 检查源码树</h3><p>属于GNU项目的程序,还有其它许多程序都会提供文档文件README,INSTALL,NEWS和COPYING.<br>这些文件包含了程序描述,如果建立和安装它的信息,还有它的许可条款.</p>
<h3 id="23-3-1-构建程序"><a href="#23-3-1-构建程序" class="headerlink" title="23.3.1 构建程序"></a>23.3.1 构建程序</h3><p>大多数程序通过简单的两个命令的序列构建:</p>
<pre><code>./configure
make</code></pre><p>configure程序是一个shell脚本,由源码树提供.它的工作室分析程序建立环境.<br>Makefile是一个配置文件,指示make程序究竟如何构建程序.没有它,make程序不能运行.<br>make程序把makefile文件作为输入,makefile文件描述了包括最终完成的程序的个组件之间的关系和依赖性.</p>
<h3 id="23-3-2-安装程序"><a href="#23-3-2-安装程序" class="headerlink" title="23.3.2 安装程序"></a>23.3.2 安装程序</h3><p>打包良好的源码经常包括一个特别的make目录文件,叫做install.这个目标文件将在系统目录中安装最终的产品,以供使用.通常,这个目录是/usr/local/bin,这是本地所构建软件的传统安装位置.</p>
<pre><code>sudo make install</code></pre><h2 id="1-24-编写第一个Shell脚本"><a href="#1-24-编写第一个Shell脚本" class="headerlink" title="1.24 编写第一个Shell脚本"></a>1.24 编写第一个Shell脚本</h2><h3 id="24-1-什么是shell脚本"><a href="#24-1-什么是shell脚本" class="headerlink" title="24.1 什么是shell脚本"></a>24.1 什么是shell脚本</h3><p>一个shell脚本就是一个包含一系列命令的文件.<br>shell不仅是一个功能强大的命令行接口,也是一个脚本语言解释器.</p>
<h3 id="24-2-怎样编写一个shell脚本"><a href="#24-2-怎样编写一个shell脚本" class="headerlink" title="24.2 怎样编写一个shell脚本"></a>24.2 怎样编写一个shell脚本</h3><p>为了成功创建和运行一个shell脚本,我们需要做三件事:</p>
<ol>
<li>编写一个脚本.</li>
<li>使脚本文件可执行.</li>
<li>把脚本放置到shell能够找到的地方.</li>
</ol>
<h3 id="24-3-脚本文件格式"><a href="#24-3-脚本文件格式" class="headerlink" title="24.3 脚本文件格式"></a>24.3 脚本文件格式</h3><pre><code>#!/bin/bash
# This is our first script.
echo &apos;Hello World!&apos;</code></pre><p>#!字符序列是一种特殊的结构叫做shebang.它被用来告诉操作系统将执行此脚本所用的解释器的名字.<br>在文本行中,#副后之后的所有字符都会被忽略.</p>
<h3 id="24-4-可执行权限"><a href="#24-4-可执行权限" class="headerlink" title="24.4 可执行权限"></a>24.4 可执行权限</h3><p>对于脚本文件,有两个常见的权限设置:</p>
<ol>
<li>权限为755的脚本,则每个人都能执行.</li>
<li>权限为700的脚本,只有文件所有者能够执行.</li>
</ol>
<h3 id="24-5-脚本文件位置"><a href="#24-5-脚本文件位置" class="headerlink" title="24.5 脚本文件位置"></a>24.5 脚本文件位置</h3><p>为了能够运行此脚本,我们必须指定脚本文件明确的路径.</p>
<pre><code>echo $PATH</code></pre><p>查看PATH目录</p>
<pre><code>export PATH=~/bin:&quot;$PATH&quot;</code></pre><p>通过在.bashrc文件中添加下面这一行,使其在新的终端会话中生效.为了把这个修改应用到当前的终端会话中,通过”sourcing”.bashrc文件来完成.</p>
<pre><code>..bashrc</code></pre><p>这个点”.”命令是source命令的同义词,一个shell内部命令,用来读取一个制定的shel命令文件,并把它看作是从键盘中输入的一样.</p>
<p>注意:在Ubuntu系统中,如果存在<del>/bin目录,当执行用户的.bashrc文件时,Ubuntu会自动地添加这个</del>/bin目录到PATH变量中.所以在Ubuntu系统中,如果我们创建了这个~/bin目录,随后退出,然后再登陆,一切会正常运行.</p>
<pre><code>~/bin           目录用来存放个人使用的脚本.
/usr/local/bin  目录用来存放本地用户的脚本.
/usr/local/sbin 目录用来存放系统管理使用的脚本.
/bin | /usr/bin 目录用来存放Linux发行商提供和维护的文件(不要将个人或本地脚本存放于此).</code></pre><h3 id="24-6-更多的格式技巧"><a href="#24-6-更多的格式技巧" class="headerlink" title="24.6 更多的格式技巧"></a>24.6 更多的格式技巧</h3><p>一个脚本可以轻松地被作者或其它用户修改,使它适应变化的需求.让脚本容易阅读和理解是一种方便维护的方法.</p>
<h4 id="24-6-1-长选项名称"><a href="#24-6-1-长选项名称" class="headerlink" title="24.6.1 长选项名称"></a>24.6.1 长选项名称</h4><p>长选项命令</p>
<pre><code>ls --all --directory</code></pre><p>短选项命令<br>    ls -ad<br>这两个命令是等价的.</p>
<ol>
<li>为了减少输入,当在命令行中输入选项的时候,短选项更受欢迎.</li>
<li>当书写脚本的时候,长选项能提供可读性.</li>
</ol>
<h4 id="24-6-2-缩进和行继续符"><a href="#24-6-2-缩进和行继续符" class="headerlink" title="24.6.2 缩进和行继续符"></a>24.6.2 缩进和行继续符</h4><p>当使用长命令的时候,通过把命令在几个文本行中展开,可以提高命令的可读性.</p>
<pre><code>find playground \
    \(\
        -type f \
        -not -perm 066 \
        -exec chmod 066 &apos;{}&apos; &apos;;&apos; \
    \)\
    -or \
    \(\
        -type d \
        -not -perm 0711 \
        -exec chmod 0711 &apos;{}&apos; &apos;;&apos;\
        \)</code></pre><p>通过使用行继续符(反斜杠-回车符序列)和缩进,使复杂命令的逻辑性更清楚地描述给读者.这个技巧在命令行中同样生效.脚本和命令行的一个区别是,脚本可能雇佣tab字符拉来实现缩进,然而命令行却不能,因为tab字符被用来激活自动补全功能.</p>
<h2 id="1-25-启动一个项目"><a href="#1-25-启动一个项目" class="headerlink" title="1.25 启动一个项目"></a>1.25 启动一个项目</h2><h3 id="25-1-第一阶段-最小的文档"><a href="#25-1-第一阶段-最小的文档" class="headerlink" title="25.1 第一阶段:最小的文档"></a>25.1 第一阶段:最小的文档</h3><pre><code>vim sys_info_page
    #!/bin/bash
    #Program to output a system information page
    echo &quot;&lt;HTML&gt;
        &lt;HEAD&gt;
            &lt;TITLE&gt;Page Title&lt;/TITLE&gt;
        &lt;/HEAD&gt;
        &lt;BODY&gt;
            Page body.
        &lt;/BODY&gt;
    &lt;/HTML&gt;&quot;
chmod 755 ~/bin/sys_info_page
sys_info_page &gt; sys_info_page.html
firefox sys_info_page.html</code></pre><p>一个带引号的字符串可能包含换行符,因此可以包含多个文本行.Shell会持续读取文本直到遇到右引号.它在命令行中也是这样工作的.</p>
<h3 id="25-2-第二阶段-添加一点儿数据"><a href="#25-2-第二阶段-添加一点儿数据" class="headerlink" title="25.2 第二阶段:添加一点儿数据"></a>25.2 第二阶段:添加一点儿数据</h3><pre><code>#!/bin/bash
#Program to output a system information page
echo &quot;&lt;HTML&gt;
        &lt;HEAD&gt;
            &lt;TITLE&gt;System Information Report&lt;/TITLE&gt;
        &lt;/HEAD&gt;
        &lt;BODY&gt;
            &lt;H1&gt;System Information Report&lt;/H1&gt;
        &lt;/BODY&gt;
    &lt;/HTML&gt;&quot;</code></pre><h3 id="25-3-变量和常量"><a href="#25-3-变量和常量" class="headerlink" title="25.3 变量和常量"></a>25.3 变量和常量</h3><pre><code>#!/bin/bash
# Program to output a system information page
title=&quot;System Information Report&quot;
echo &quot;&lt;HTML&gt;
        &lt;HEAD&gt;
            &lt;TITLE&gt;$title&lt;/TITLE&gt;
        &lt;/HEAD&gt;
        &lt;BODY&gt;
            &lt;H1&gt;$title&lt;/H1&gt;
        &lt;/BODY&gt;
    &lt;/HTML&gt;&quot;</code></pre><p>通过创建一个名为title的变量,并把”System Information Report”字符串赋值给它,就可以利用参数展开功能,把这个字符串放到文件中的多个位置.<br>注意:如果输入失误创建了一个控变量展开值为空,这对于需要参数的命令来说,会引起混乱.</p>
<pre><code>foo=foo.txt
foo1=foo1.txt
cp $foo $foo1
cp: missing destination file operand after &apos;foo.txt&apos;</code></pre><p>当shell碰到一个变量的时候,它会自动地创建它.关于这个问题,shell要求非常宽松,这可能会导致一些问题.</p>
<pre><code>foo=&quot;yes&quot;
echo $foo
yes
echo $fool
$</code></pre><p>首先我们把”yes”赋给变量foo,然后用echo命令来显示变量值.接着,我们显示拼写错误的变量名”fool”的变量值,然后得到一个空值.这是因为shell很高兴地创建了变量fool,当shell遇到fool的时候,并且赋给fool一个空的默认值.因此,我们必须小心谨慎地拼写.</p>
<p>变量名的规则:</p>
<ol>
<li>变量名可由字母数字字符(字母和数字)和下划线字符组成.</li>
<li>变量名的第一个字符必须是一个字母或一个下划线.</li>
<li>变量名中不允许出现空格和标点符号.</li>
</ol>
<p>shell不能辨别常量和变量;它们大多数情况下是为了方便程序员.一个常用惯例是指定大写字母来表示常量,小写字母表示真正的变量.</p>
<pre><code>#!/bin/bash
#Program to output a system information page
TITLE=&quot;System InformationReport For $HOSTNAME&quot;
echo &quot;&lt;HTML&gt;
        &lt;HEAD&gt;
            &lt;TITLE&gt;$title&lt;/TITLE&gt;
        &lt;/HEAD&gt;
        &lt;BODY&gt;
            &lt;H1&gt;$title&lt;/H1&gt;
        &lt;/BODY&gt;
    &lt;/HTML&gt;</code></pre><p>通过在标题中添加shell变量名HOSTNAME,让标题变得活泼有趣些.这个变量名是这台机器的网络名称.</p>
<h4 id="25-3-1-给变量和常量赋值"><a href="#25-3-1-给变量和常量赋值" class="headerlink" title="25.3.1 给变量和常量赋值"></a>25.3.1 给变量和常量赋值</h4><pre><code>variable=value</code></pre><p>这里的variable是变量的名字,value是一个字符串.不同于一些其它的编程语言,shell不会在乎变量值的类型;它把它们都看作是字符串.</p>
<p>注意:在赋值过程中,变量名,等号和变量值之间必须没有空格.</p>
<p>在参数展开过程中,变量名可以被花括号”{}”包围.在变量名周围的上下文变得不明确的情况下,这会很有帮助.</p>
<pre><code>filename=&quot;myfile&quot;
touch $filename
mv $filename $filename1
mv:missing destination file operand after &apos;myfile&apos;</code></pre><p>因为shell把mv命令的第二个参数解释为一个新的空的变量.</p>
<pre><code>mv $filename ${filename}1</code></pre><p>通过添加花括号,shell不再把末尾的1解释为变量名的一部分.</p>
<pre><code>#!/bin/bash
# Program to output a system information page
TITLE=&quot;System Information Report For $HOSTNAME&quot;
CURRENT_TIME=$(date +&quot;%x %r %Z&quot;)
TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot;
echo &quot;&lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
        &lt;H1&gt;$TITLE&lt;/H1&gt;
        &lt;P&gt;$TIME_STAMP&lt;/P&gt;
    &lt;/BODY&gt;
&lt;/HTML&gt;&quot;</code></pre><h3 id="25-4-Here-Documents"><a href="#25-4-Here-Documents" class="headerlink" title="25.4 Here Documents"></a>25.4 Here Documents</h3><p>第三种文本输出方法叫做here document 或者 here script.<br>一个 here document 是另外一种I/O重定向形式.<br>我们在脚本文件中嵌入正文文本,然后把它发送给一个命令的标准输入.</p>
<pre><code>command &lt;&lt; token
text
token</code></pre><p>这里的command是一个可以接受标准输入的命令名,token是一个用来指示嵌入文本结束的字符串.</p>
<pre><code>#!/bin/bash
# Program to output a system information page
TITLE=&quot;System Information Report For $HOSTNAME&quot;
CURRENT_TIME=$(date +&quot;%x %r %Z&quot;)
TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot;
cat &lt;&lt; _EOF_
    &lt;HTML&gt;
        &lt;HEAD&gt;
            &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
        &lt;/HEAD&gt;
        &lt;BODY&gt;
            &lt;H1&gt;$TITLE&lt;/H1&gt;
            &lt;P&gt;$TIME_STAMP&lt;/P&gt;
        &lt;/BODY&gt;
        &lt;/HTML&gt;
    _EOF_</code></pre><p>取代echo命令,现在我们的脚本使用cat命令和一个here document.这个字符串<em>EOF</em>(意思是”文件结尾”,一个常见用法)被选作为token,并标志着嵌入文本的结尾.注意这个token必须在一行中单独出现,并且文本行中没有末尾的空格.</p>
<p>在here document中,shell不会注意引号.引号被看作是普通的字符.这就允许我们在一个here document中可以随意的嵌入引号.</p>
<p>Here documents可以和任意能接受标准输入的命令一块使用.</p>
<pre><code>#!/bin/bash
# Script to retrieve a file via FTP
FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz
ftp -n &lt;&lt; _EOF_
open $FTP_SERVER
user anonymous me@linuxbox
cd $FTP_PATH
hash
get $REMOTE_FILE
bye
_EOF_
ls -l $REMOTE_FILE</code></pre><p>如果我们把重定向操作符从”&lt;&lt;”改为”&lt;&lt;-“,shell会忽略在此here document中开头的tab字符.这就能缩进一个here document,从而提高脚本的可读性.</p>
<pre><code>#!/bin/bash
# Script to retrieve a file via FTP
FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz
ftp -n &lt;&lt;- _EOF_
open $FTP_SERVER
user anonymous me@linuxbox
cd $FTP_PATH
hash
get $REMOTE_FILE
bye
_EOF_
ls -l $REMOTE_FILE</code></pre><h2 id="1-26-自顶向下设计"><a href="#1-26-自顶向下设计" class="headerlink" title="1.26 自顶向下设计"></a>1.26 自顶向下设计</h2><p>先确定上层步骤,然后再逐步西华这些步骤的过程被称为自顶向下设计.这种技巧允许我们把庞大而复杂的任务分割为许多小而简单的任务.自顶向下设计是一种常见的程序设计方法,尤其适合shell编程.</p>
<h3 id="26-1-shell函数"><a href="#26-1-shell函数" class="headerlink" title="26.1 shell函数"></a>26.1 shell函数</h3><p>目前我们的脚本执行以下步骤来产生HTML文档:</p>
<ol>
<li>打开网页</li>
<li>打开网页标头</li>
<li>设置网页标题</li>
<li>关闭网页标头</li>
<li>打开网页主体部分</li>
<li>输出网页标头</li>
<li>输出时间戳</li>
<li>关闭网页主体</li>
<li>关闭网页</li>
</ol>
<p>为了下一阶段的开发,我们将在步骤7和8之间添加一些额外的任务.这些包括:</p>
<ol>
<li>系统正常运行时间和负载.这是自上次关机或重启之后系统的运行时间,以及在几个时间间隔内当前运行在处理中的平均任务量.</li>
<li>磁盘空间.系统中存储设备的总使用量.</li>
<li>家目录空间.每个用户所使用的存储空间数量.</li>
</ol>
<p>如果对于每个任务,我们都有相应的命令,那么通过命令替换,我们就能很容易地把它们添加到我们的脚本中.</p>
<pre><code>#!/bin/bash
# Program to output a system information page
TITLE=&quot;System Information Report For $HOSTNAME&quot;
CURRENT_TIME=$(date +&quot;%x %r %Z&quot;)
TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot;
cat &lt;&lt; _EOF_
    &lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
        &lt;H1&gt;$TITLE&lt;/H1&gt;
        &lt;P&gt;$TIME_STAMP&lt;/P&gt;
        $(report_uptime)
        $(report_disk_space)
        $(report_home_space)
    &lt;/BODY&gt;
&lt;/HTML&gt;
_EOF_</code></pre><p>我们可以使用两种方法创建这些额外的命令.</p>
<ol>
<li><p>可以分别编写三个脚本,并把它们放置到环境变量PATH所列出的目录下;</p>
</li>
<li><p>可以把这些脚本作为shell函数嵌入到程序中.shell函数是位于其它脚本中的”微脚本”,作为自主程序.shell函数由两种语法形式:</p>
<ol>
<li><p>function name {<br> commands<br> return<br> }</p>
</li>
<li><p>name () {<br> commands<br> return<br> }<br>这里的name是函数名,commands是一系列包含在函数中的命令.<br>两种形式是等价的,可以交替使用.<br>注意:为了使函数调用被识别出是shell函数,而不是被解释为外部程序的名字,所以在脚本中shell函数定义必须出现在函数调用之前.</p>
<p>#!/bin/bash<br>#Program to output a system information page<br>TITLE=”System Information Report For $HOSTNAME”<br>CURRENT_TIME=$(date +”%x %r %Z”)<br>TIME_STAMP=”Generated $CURRENT_TIME, by $USER”<br>report_uptime () {<br>return<br>}<br>report_disk_space () {<br>return<br>}<br>report_home_space () {<br>return<br>}<br>cat &lt;&lt; <em>EOF</em></p>
 <HTML>

<pre><code>&lt;HEAD&gt;

&lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;BODY&gt;
    &lt;H1&gt;$TITLE&lt;/H1&gt;
    &lt;P&gt;$TIME_STAMP&lt;/P&gt;
        $(report_uptime)
        $(report_disk_space)
        $(report_home_space)
&lt;/BODY&gt;</code></pre> </HTML>
 _EOF_

</li>
</ol>
</li>
</ol>
<p>shell函数的命名规则和变量一样.一个函数必须至少包含一条命令.return命令(是可选的)满足要求.</p>
<h3 id="26-2-局部变量"><a href="#26-2-局部变量" class="headerlink" title="26.2 局部变量"></a>26.2 局部变量</h3><p>局部变量只能在定义它们的shell函数中使用,并且一旦shell函数执行完毕,它们就不存在了.<br>拥有局部变量允许程序员使用的局部变量名,可以与已存在的变量名相同,这些变量可以是全局变量,或者是其它shell函数中的局部变量,不用担心名字冲突.</p>
<pre><code>#!/bin/bash
# local-vars: script to demonstrate local variables
foo=0 # global variable foo
funct_1 () {
local foo
# variable foo local to funct_1
foo=1
echo &quot;funct_1: foo = $foo&quot;
}
funct_2 () {
local foo
# variable foo local to funct_2
foo=2
echo &quot;funct_2: foo = $foo&quot;
}
echo &quot;global:
foo = $foo&quot;
funct_1
echo &quot;global: foo = $foo&quot;
funct_2</code></pre><p>通过在变量名之前加上单词local,来定义局部变量.这就创建了一个只对其所在的shell函数起作用的变量.在这个shell函数之外,这个变量不再存在.<br>这个功能允许shell函数能保持各自以及与它们所在脚本之间的独立性.</p>
<h3 id="26-3-保持脚本运行"><a href="#26-3-保持脚本运行" class="headerlink" title="26.3 保持脚本运行"></a>26.3 保持脚本运行</h3><h2 id="1-27-流程控制-if分支结构"><a href="#1-27-流程控制-if分支结构" class="headerlink" title="1.27 流程控制:if分支结构"></a>1.27 流程控制:if分支结构</h2><p>怎样使我们的报告生成器脚本能适应运行此脚本的用户的权限,在脚本中基于测试条件结果,来”改变方向”.</p>
<h3 id="1-27-1-if"><a href="#1-27-1-if" class="headerlink" title="1,27,1 if"></a>1,27,1 if</h3><p>逻辑如下:<br>    x=5<br>    if [ $x = 5]; then<br>        echo “x equals 5.”<br>    else<br>        echo “x does not equal 5.”<br>    fi</p>
<p>if语句语法如下:</p>
<pre><code>if commands; then
    commands
[elif commands; then
    commands...]
[else
    commands]
fi</code></pre><p>这里的commands是指一系列命令.</p>
<h3 id="27-2-退出状态"><a href="#27-2-退出状态" class="headerlink" title="27.2 退出状态"></a>27.2 退出状态</h3><p>当命令执行完毕后,命令(包含我们编写的脚本和shell函数)会给系统发送一个值,叫做退出状态.这个值是一个0到255之间的整数,说明命令执行成功或是失败.按照惯例,一个零值说明成功,其它所有值说明失败.shell提供了一个参数(echo $?),我们可以用它来检查退出状态.</p>
<h3 id="27-3-测试"><a href="#27-3-测试" class="headerlink" title="27.3 测试"></a>27.3 测试</h3><p>目前为止,经常与if一块使用的命令是test.这个test命令执行各种各样的检查与比较.</p>
<ol>
<li>test expression</li>
<li>[ expression]</li>
</ol>
<p>这里的expression是一个表达式,其执行结果是true或者是false.当表达式为真时,这个test命令返回一个零退出状态,当表达式为假时,test命令退出状态为1.</p>
<h4 id="27-3-1-文件表达式"><a href="#27-3-1-文件表达式" class="headerlink" title="27.3.1 文件表达式"></a>27.3.1 文件表达式</h4><pre><code>表达式               如果为真
file1 -ef file2     file1和file2拥有相同的索引号(通过硬链接两个文件名指向相同的文件).
file1 -nt file2     file1新与file2.
file1 -ot file2     file1早于file2.
-b file             file存在并且是一个块(设备)文件.
-c file             file存在并且是一个字符(设备)文件.
-d file             file存在并且是一个目录.
-e file             file存在.
-f file             file存在并且是一个普通文件.
-g file             file存在并且设置了组ID.
-G file             file存在并且由有效组ID拥有.
-k file             file存在并且设置了它的&quot;sticky bit&quot;.
-L file             file存在并且是一个符号链接.
-O file             file存在并且由有效用户ID拥有.
-p file             file存在并且是一个命名管道.
-r file             file存在并且可读(有效用户有可读权限).
-s file             file存在且其长度大于零.
-S file             file存在且是一个网络socket.
-t fd               fd是一个定向到终端/从终端定向到文件描述符.
                    这可以被用来决定是否重定向了标准输入/输出错误.
-u file             file存在并且设置了setuid位.
-w file             file存在并且可写.
-x file             file存在并且可执行.</code></pre><h4 id="27-3-2-字符串表达式"><a href="#27-3-2-字符串表达式" class="headerlink" title="27.3.2 字符串表达式"></a>27.3.2 字符串表达式</h4><pre><code>表达式               如果为真
string              string不为null.
-n string           字符串string的长度大于零.
-z string           字符串string的长度为零.
string1 = string2   string1和string2相同.单或双等号都可以,不过双等号更受欢迎.
string1 != string2  string1 和string2不相同.
string1 &gt; string2   string1排列在string2之后.
string1 &lt; string2   string1排列在string2之前.</code></pre><p>注意:这个&gt;和&lt;表达式操作符必须用引号引起来(或者使用反斜杠转义),当与test一块使用的时候.如果不这样,它们会被shell解释为重定向操作符,造成潜在地破坏结果.同时也要注意虽然bash文档生命排序遵从当前语系的排列规则,但并不这样.将来的bash版本,包括4.0,使用ASCII(POSIX)排序规则.</p>
<pre><code>#!/bin/bash
# test-string: evaluate the value of a string
ANSWER=maybe
if [ -z &quot;$ANSWER&quot; ]; then
echo &quot;There is no answer.&quot; &gt;&amp;2
exit 1
fi
if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then
echo &quot;The answer is YES.&quot;
elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then
echo &quot;The answer is NO.&quot;
elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then
echo &quot;The answer is MAYBE.&quot;
else
echo &quot;The answer is UNKNOWN.&quot;
fi</code></pre><p>在这个脚本中,我们计算常量ANSWER.我们首先确定是否此字符串为空.如果为空,我们就终止脚本,并把退出状态设为零.注意这个应用于echo命令的重定向操作.其把错误信息”There is no answer.”重定向到标准错误,这是处理错误信息的”合理”方法.如果字符串不为空,我们就计算字符串的值,看看它是否等于”yes”,”no”或者”maybe”.为此使用elif,它是”else if”的简写.通过使用elif,我们能够构建更复杂的逻辑测试.</p>
<h4 id="27-3-3-整型表达式"><a href="#27-3-3-整型表达式" class="headerlink" title="27.3.3 整型表达式"></a>27.3.3 整型表达式</h4><pre><code>表达式                       如果为真
integer1 -eq integer2       integer1等于integer2.
integer1 -ne integer2       integer1不等于integer2.
integer1 -le integer2       integer1小于或等于integer2.
integer1 -lt integer2       integer1小于integer2.
integer1 -ge integer2       integer1大于或等于integer2.
integer1 -gt integer2       integer1大于integer2.</code></pre><p>例:<br>    #!/bin/bash<br>    # test-integer: evaluate the value of an integer.<br>    INT=-5<br>    if [ -z “$INT” ]; then<br>    echo “INT is empty.” &gt;&amp;2<br>    exit 1<br>    fi<br>    if [ $INT -eq 0 ]; then<br>    echo “INT is zero.”<br>    else<br>    if [ $INT -lt 0 ]; then<br>    echo “INT is negative.”<br>    else<br>    echo “INT is positive.”<br>    fi<br>    if [ $((INT % 2)) -eq 0 ]; then<br>    echo “INT is even.”<br>    else<br>    echo “INT is odd.”<br>    fi<br>    fi<br>确定一个整数是偶数还是奇数。通过用模数 2 对数字执行<br>求模操作,就是用数字来除以 2,并返回余数,从而知道数字是偶数还是奇数。</p>
<h3 id="27-4-更现代的测试版本"><a href="#27-4-更现代的测试版本" class="headerlink" title="27.4 更现代的测试版本"></a>27.4 更现代的测试版本</h3><pre><code>[[ expression]]</code></pre><p>这里,类似于 test,expression 是一个表达式,其计算结果为真或假。这个 [[ ]] 命令非<br>常相似于 test 命令(它支持所有的表达式),但是增加了一个重要的新的字符串表达式:<br>    string1 =~ regex<br>其返回值为真,如果 string1 匹配扩展的正则表达式 regex。这就为执行比如数据验证等任<br>务提供了许多可能性。在我们前面的整数表达式示例中,如果常量 INT 包含除了整数之外的<br>任何数据,脚本就会运行失败。这个脚本需要一种方法来证明此常量包含一个整数。使用 [[<br>]] 和 =∼ 字符串表达式操作符.</p>
<pre><code>#!/bin/bash
# test-integer2: evaluate the value of an integer.
INT=-5
if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
    if [ $INT -eq 0 ]; then
        echo &quot;INT is zero.&quot;
    else
    if [ $INT -lt 0 ]; then
    echo &quot;INT is negative.&quot;
    else
    echo &quot;INT is positive.&quot;
        fi
    if [ $((INT % 2)) -eq 0 ]; then
    echo &quot;INT is even.&quot;
    else
    echo &quot;INT is odd.&quot;
        fi
    fi
else
echo &quot;INT is not an integer.&quot; &gt;&amp;2
exit 1
fi</code></pre><p>通过应用正则表达式,我们能够限制 INT 的值只是字符串,其开始于一个可选的减号,随<br>后是一个或多个数字。这个表达式也消除了空值的可能性。</p>
<p>[[ ]] 添加的另一个功能是 == 操作符支持类型匹配,正如路径名展开所做的那样。例如:</p>
<pre><code>FILE=foo.bar
if [[ $FILE == foo.* ]]; then
echo &quot;$FILE matches pattern &apos;foo.*&apos;&quot;
fi</code></pre><p>这就使 [[ ]] 有助于计算文件和路径名。</p>
<h3 id="27-5-为整数设计"><a href="#27-5-为整数设计" class="headerlink" title="27.5 (()) 为整数设计"></a>27.5 (()) 为整数设计</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
